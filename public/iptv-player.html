<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>XPENG IPTV Player - Web App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #f1f5f9;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #06b6d4, #3b82f6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            overflow-x: auto;
            padding-bottom: 4px;
        }
        
        .tab {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            white-space: nowrap;
            font-size: 14px;
            font-weight: 500;
        }
        
        .tab:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }
        
        .tab.active {
            background: linear-gradient(135deg, #06b6d4, #3b82f6);
            border-color: transparent;
            box-shadow: 0 4px 12px rgba(6, 182, 212, 0.3);
        }
        
        .content-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }
        
        .media-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .media-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            border-color: rgba(6, 182, 212, 0.5);
        }
        
        .media-card img {
            width: 100%;
            height: 240px;
            object-fit: cover;
            background: linear-gradient(135deg, #1e293b, #334155);
        }
        
        .media-card .info {
            padding: 12px;
        }
        
        .media-card .title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .media-card .category {
            font-size: 12px;
            color: #94a3b8;
        }
        
        .favorite-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s;
        }
        
        .favorite-btn:hover {
            background: rgba(239, 68, 68, 0.8);
            transform: scale(1.1);
        }
        
        .favorite-btn.active {
            background: rgba(239, 68, 68, 0.9);
        }
        
        .epg-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .epg-timeline {
            display: flex;
            gap: 16px;
            overflow-x: auto;
            padding-bottom: 16px;
        }
        
        .epg-program {
            min-width: 300px;
            background: rgba(255, 255, 255, 0.08);
            padding: 16px;
            border-radius: 8px;
            border-left: 4px solid #06b6d4;
        }
        
        .epg-program.current {
            border-left-color: #22c55e;
            background: rgba(34, 197, 94, 0.1);
        }
        
        .epg-time {
            font-size: 12px;
            color: #94a3b8;
            margin-bottom: 4px;
        }
        
        .epg-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .epg-description {
            font-size: 13px;
            color: #cbd5e1;
            line-height: 1.4;
        }
        
        .setup-form, .player-section {
            background: rgba(255, 255, 255, 0.08);
            padding: 30px;
            border-radius: 16px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 20px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #cbd5e1;
        }
        
        input, select {
            width: 100%;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #f1f5f9;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #06b6d4;
            background: rgba(255, 255, 255, 0.15);
        }
        
        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #06b6d4, #3b82f6);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(6, 182, 212, 0.4);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            margin-left: 10px;
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .channels-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        
        .channel-card {
            background: rgba(255, 255, 255, 0.08);
            padding: 15px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .channel-card:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateY(-2px);
            border-color: #06b6d4;
        }
        
        .channel-card h3 {
            font-size: 16px;
            margin-bottom: 5px;
            color: #f1f5f9;
        }
        
        .channel-card p {
            font-size: 12px;
            color: #94a3b8;
        }
        
        .video-player {
            margin-top: 20px;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
        }
        
        video {
            width: 100%;
            max-height: 600px;
        }
        
        .hidden {
            display: none;
        }
        
        .status-message {
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        .status-success {
            background: rgba(34, 197, 94, 0.2);
            border: 1px solid rgba(34, 197, 94, 0.5);
            color: #86efac;
        }
        
        .status-error {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.5);
            color: #fca5a5;
        }
        
        .search-box {
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #f1f5f9;
            font-size: 14px;
        }
        
        .current-playing {
            background: rgba(6, 182, 212, 0.2);
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 1px solid #06b6d4;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé¨ XPENG IPTV Player</h1>
            <p>Web App optimis√©e pour navigateur XPENG</p>
            <p style="font-size: 12px; margin-top: 8px; color: #94a3b8;">‚úÖ Support HLS/M3U8 ‚Ä¢ Hardware Decode ‚Ä¢ Twine4Car Compatible</p>
        </div>
        
        <div id="setupSection" class="setup-form">
            <h2 style="margin-bottom: 20px;">üì° Configuration IPTV</h2>
            
            <div class="form-group">
                <label for="connectionType">Type de connexion :</label>
                <select id="connectionType" onchange="updateFormFields()">
                    <option value="m3u">URL M3U/M3U8</option>
                    <option value="xtream">Xtream Codes API</option>
                </select>
            </div>
            
            <div id="m3uFields">
                <div class="form-group">
                    <label for="m3uUrl">URL de la playlist M3U :</label>
                    <input type="url" id="m3uUrl" placeholder="https://example.com/playlist.m3u8">
                </div>
            </div>
            
            <div id="xtreamFields" class="hidden">
                <div class="form-group">
                    <label for="xtreamUrl">URL du serveur :</label>
                    <input type="url" id="xtreamUrl" placeholder="http://server.com:port">
                </div>
                <div class="form-group">
                    <label for="xtreamUsername">Nom d'utilisateur :</label>
                    <input type="text" id="xtreamUsername" placeholder="username">
                </div>
                <div class="form-group">
                    <label for="xtreamPassword">Mot de passe :</label>
                    <input type="password" id="xtreamPassword" placeholder="password">
                </div>
            </div>
            
            <button onclick="saveAndConnect()">üíæ Sauvegarder et Charger</button>
            <button class="btn-secondary" onclick="clearStorage()">üóëÔ∏è Effacer les donn√©es</button>
        </div>
        
        <div id="playerSection" class="player-section hidden">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2>üì∫ Contenu IPTV</h2>
                <button class="btn-secondary" onclick="showSetup()">‚öôÔ∏è Configuration</button>
            </div>
            
            <!-- Onglets de navigation -->
            <div class="tabs">
                <div class="tab active" onclick="switchTab('live')" id="tabLive">
                    üì° Direct TV
                </div>
                <div class="tab" onclick="switchTab('movies')" id="tabMovies">
                    üé¨ Films
                </div>
                <div class="tab" onclick="switchTab('series')" id="tabSeries">
                    üì∫ S√©ries
                </div>
                <div class="tab" onclick="switchTab('epg')" id="tabEpg">
                    üìã Guide (EPG)
                </div>
                <div class="tab" onclick="switchTab('favorites')" id="tabFavorites">
                    ‚ù§Ô∏è Favoris
                </div>
                <div class="tab" onclick="switchTab('history')" id="tabHistory">
                    üïê Historique
                </div>
            </div>
            
            <input type="text" id="searchBox" class="search-box" placeholder="üîç Rechercher..." onkeyup="filterContent()">
            
            <div id="statusMessage"></div>
            
            <div id="currentPlaying" class="current-playing hidden">
                <strong>‚ñ∂Ô∏è En cours :</strong> <span id="playingName">-</span>
            </div>
            
            <div id="videoContainer" class="video-player hidden">
                <video id="videoPlayer" 
                       controls 
                       autoplay 
                       playsinline 
                       preload="metadata"
                       webkit-playsinline
                       x-webkit-airplay="allow"
                       style="width: 100%; height: 100%; object-fit: contain;">
                    Votre navigateur ne supporte pas la vid√©o HTML5.
                </video>
            </div>
            
            <!-- Section Live TV -->
            <div id="sectionLive" class="content-section">
                <div id="channelsList" class="channels-grid"></div>
            </div>
            
            <!-- Section Films -->
            <div id="sectionMovies" class="content-section hidden">
                <div id="moviesList" class="content-grid"></div>
            </div>
            
            <!-- Section S√©ries -->
            <div id="sectionSeries" class="content-section hidden">
                <div id="seriesList" class="content-grid"></div>
            </div>
            
            <!-- Section EPG -->
            <div id="sectionEpg" class="content-section hidden">
                <div id="epgContainer" class="epg-container">
                    <h3 style="margin-bottom: 16px;">üìã Guide des programmes</h3>
                    <div id="epgTimeline" class="epg-timeline"></div>
                </div>
            </div>
            
            <!-- Section Favoris -->
            <div id="sectionFavorites" class="content-section hidden">
                <div id="favoritesList" class="content-grid"></div>
            </div>
            
            <!-- Section Historique -->
            <div id="sectionHistory" class="content-section hidden">
                <div id="historyList" class="content-grid"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
        // Variables globales
        let channels = [];
        let movies = [];
        let series = [];
        let epgData = [];
        let favorites = JSON.parse(localStorage.getItem('iptvFavorites') || '[]');
        let history = JSON.parse(localStorage.getItem('iptvHistory') || '[]');
        let hls = null;
        let currentTab = 'live';
        
        // Charger la configuration sauvegard√©e au d√©marrage
        window.onload = function() {
            loadSavedConfig();
            loadFavorites();
            loadHistory();
        };
        
        // Gestion des onglets
        function switchTab(tabName) {
            currentTab = tabName;
            
            // Mettre √† jour les onglets actifs
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById('tab' + tabName.charAt(0).toUpperCase() + tabName.slice(1)).classList.add('active');
            
            // Masquer toutes les sections
            document.querySelectorAll('.content-section').forEach(section => section.classList.add('hidden'));
            
            // Afficher la section active
            document.getElementById('section' + tabName.charAt(0).toUpperCase() + tabName.slice(1)).classList.remove('hidden');
            
            // Charger le contenu si n√©cessaire
            if (tabName === 'movies' && movies.length === 0) {
                loadMovies();
            } else if (tabName === 'series' && series.length === 0) {
                loadSeries();
            } else if (tabName === 'epg' && epgData.length === 0) {
                loadEPG();
            } else if (tabName === 'favorites') {
                displayFavorites();
            } else if (tabName === 'history') {
                displayHistory();
            }
        }
        
        // Ajouter aux favoris
        function toggleFavorite(item) {
            const index = favorites.findIndex(f => f.url === item.url);
            
            if (index > -1) {
                favorites.splice(index, 1);
                debugLog(`‚ùå Retir√© des favoris: ${item.name}`, 'info');
            } else {
                favorites.push({...item, addedAt: Date.now()});
                debugLog(`‚úÖ Ajout√© aux favoris: ${item.name}`, 'success');
            }
            
            localStorage.setItem('iptvFavorites', JSON.stringify(favorites));
            
            // Rafra√Æchir l'affichage
            if (currentTab === 'favorites') {
                displayFavorites();
            }
        }
        
        // Ajouter √† l'historique
        function addToHistory(item) {
            // Retirer l'ancien si existe
            history = history.filter(h => h.url !== item.url);
            
            // Ajouter au d√©but
            history.unshift({...item, watchedAt: Date.now()});
            
            // Garder seulement les 50 derniers
            history = history.slice(0, 50);
            
            localStorage.setItem('iptvHistory', JSON.stringify(history));
            debugLog(`üìù Ajout√© √† l'historique: ${item.name}`, 'info');
        }
        
        // Charger et afficher favoris
        function loadFavorites() {
            favorites = JSON.parse(localStorage.getItem('iptvFavorites') || '[]');
        }
        
        function displayFavorites() {
            const container = document.getElementById('favoritesList');
            container.innerHTML = '';
            
            if (favorites.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #94a3b8; padding: 40px;">Aucun favori. Ajoutez-en en cliquant sur ‚ù§Ô∏è</p>';
                return;
            }
            
            favorites.forEach(item => {
                const card = createMediaCard(item, true);
                container.appendChild(card);
            });
        }
        
        // Charger et afficher historique
        function loadHistory() {
            history = JSON.parse(localStorage.getItem('iptvHistory') || '[]');
        }
        
        function displayHistory() {
            const container = document.getElementById('historyList');
            container.innerHTML = '';
            
            if (history.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #94a3b8; padding: 40px;">Aucun historique</p>';
                return;
            }
            
            history.forEach(item => {
                const card = createMediaCard(item, false, true);
                container.appendChild(card);
            });
        }
        
        // Cr√©er une carte m√©dia (Films/S√©ries)
        function createMediaCard(item, showFavorite = true, showDate = false) {
            const card = document.createElement('div');
            card.className = 'media-card';
            card.style.position = 'relative';
            
            const isFav = favorites.some(f => f.url === item.url);
            
            card.innerHTML = `
                ${showFavorite ? `<button class="favorite-btn ${isFav ? 'active' : ''}" onclick="event.stopPropagation(); toggleFavorite(${JSON.stringify(item).replace(/"/g, '&quot;')})">
                    ${isFav ? '‚ù§Ô∏è' : 'ü§ç'}
                </button>` : ''}
                <img src="${item.poster || 'https://via.placeholder.com/200x300/334155/f1f5f9?text=' + encodeURIComponent(item.name)}" 
                     alt="${item.name}"
                     onerror="this.src='https://via.placeholder.com/200x300/334155/f1f5f9?text=' + encodeURIComponent('${item.name}')">
                <div class="info">
                    <div class="title">${item.name}</div>
                    <div class="category">${item.category || 'Divers'}</div>
                    ${showDate && item.watchedAt ? `<div class="category">${new Date(item.watchedAt).toLocaleDateString('fr-FR')}</div>` : ''}
                </div>
            `;
            
            card.onclick = () => {
                playChannel(item);
                addToHistory(item);
            };
            
            return card;
        }
        
        // Fonction pour logger dans la console uniquement
        function debugLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString('fr-FR');
            const icon = {
                'info': '‚ÑπÔ∏è',
                'success': '‚úÖ',
                'warning': '‚ö†Ô∏è',
                'error': '‚ùå'
            }[type] || '‚ÑπÔ∏è';
            
            console.log(`${icon} [${timestamp}] ${message}`);
        }
        
        function updateFormFields() {
            const type = document.getElementById('connectionType').value;
            document.getElementById('m3uFields').classList.toggle('hidden', type !== 'm3u');
            document.getElementById('xtreamFields').classList.toggle('hidden', type !== 'xtream');
        }
        
        function saveAndConnect() {
            debugLog('üöÄ D√©marrage de la connexion...', 'info');
            
            const type = document.getElementById('connectionType').value;
            debugLog(`üì¶ Type de connexion: ${type === 'm3u' ? 'M3U/M3U8' : 'Xtream Codes'}`, 'info');
            
            let config = { type };
            
            if (type === 'm3u') {
                config.url = document.getElementById('m3uUrl').value.trim();
                debugLog('‚öôÔ∏è Validation des donn√©es M3U...', 'info');
                
                if (!config.url) {
                    debugLog('‚ùå ERREUR: URL M3U vide', 'error');
                    showStatus('‚ùå Veuillez entrer une URL M3U', 'error');
                    return;
                }
                
                if (!config.url.startsWith('http://') && !config.url.startsWith('https://')) {
                    debugLog('‚ö†Ô∏è ATTENTION: L\'URL ne commence pas par http:// ou https://', 'warning');
                    debugLog(`URL fournie: ${config.url}`, 'warning');
                }
                
                if (!config.url.includes('.m3u') && !config.url.includes('.m3u8')) {
                    debugLog('‚ö†Ô∏è ATTENTION: L\'URL ne semble pas √™tre un fichier M3U/M3U8', 'warning');
                }
                
                debugLog(`‚úÖ URL M3U valide: ${config.url}`, 'success');
                
            } else {
                config.url = document.getElementById('xtreamUrl').value.trim();
                config.username = document.getElementById('xtreamUsername').value.trim();
                config.password = document.getElementById('xtreamPassword').value.trim();
                
                debugLog('‚öôÔ∏è Validation des donn√©es Xtream...', 'info');
                
                const missing = [];
                if (!config.url) missing.push('URL serveur');
                if (!config.username) missing.push('Nom d\'utilisateur');
                if (!config.password) missing.push('Mot de passe');
                
                if (missing.length > 0) {
                    debugLog(`‚ùå ERREUR: Champs manquants: ${missing.join(', ')}`, 'error');
                    showStatus(`‚ùå Veuillez remplir: ${missing.join(', ')}`, 'error');
                    return;
                }
                
                if (!config.url.startsWith('http://') && !config.url.startsWith('https://')) {
                    debugLog('‚ùå ERREUR: L\'URL serveur doit commencer par http:// ou https://', 'error');
                    debugLog(`URL fournie: ${config.url}`, 'error');
                    showStatus('‚ùå URL serveur invalide (doit commencer par http:// ou https://)', 'error');
                    return;
                }
                
                if (config.url.endsWith('/')) {
                    debugLog('‚ö†Ô∏è URL se termine par /, sera nettoy√© automatiquement', 'warning');
                }
                
                debugLog(`‚úÖ URL serveur: ${config.url}`, 'success');
                debugLog(`‚úÖ Username: ${config.username}`, 'success');
                debugLog(`‚úÖ Password: ${'*'.repeat(config.password.length)} (${config.password.length} caract√®res)`, 'success');
                
                const specialChars = /[^a-zA-Z0-9_-]/;
                if (specialChars.test(config.username)) {
                    debugLog('‚ö†Ô∏è Username contient des caract√®res sp√©ciaux, sera encod√©', 'warning');
                }
                if (specialChars.test(config.password)) {
                    debugLog('‚ö†Ô∏è Password contient des caract√®res sp√©ciaux, sera encod√©', 'warning');
                }
            }
            
            try {
                localStorage.setItem('iptvConfig', JSON.stringify(config));
                debugLog('üíæ Configuration sauvegard√©e dans localStorage', 'success');
                showStatus('‚úÖ Configuration sauvegard√©e !', 'success');
            } catch (e) {
                debugLog(`‚ùå ERREUR localStorage: ${e.message}`, 'error');
                showStatus('‚ö†Ô∏è Configuration non sauvegard√©e (localStorage plein?)', 'warning');
            }
            
            debugLog('üöÄ Lancement du chargement des cha√Ænes...', 'info');
            loadChannels(config);
        }
        
        function loadSavedConfig() {
            const saved = localStorage.getItem('iptvConfig');
            if (saved) {
                const config = JSON.parse(saved);
                document.getElementById('connectionType').value = config.type;
                updateFormFields();
                
                if (config.type === 'm3u') {
                    document.getElementById('m3uUrl').value = config.url;
                } else {
                    document.getElementById('xtreamUrl').value = config.url;
                    document.getElementById('xtreamUsername').value = config.username;
                    document.getElementById('xtreamPassword').value = config.password;
                }
                
                // Auto-charger les cha√Ænes
                showStatus('üîÑ Chargement de la configuration sauvegard√©e...', 'success');
                setTimeout(() => loadChannels(config), 500);
            }
        }
        
        async function loadChannels(config) {
            try {
                if (config.type === 'm3u') {
                    await loadM3U(config.url);
                } else {
                    await loadXtream(config);
                }
            } catch (error) {
                showStatus('‚ùå Erreur: ' + error.message, 'error');
            }
        }
        
        async function loadM3U(url) {
            showStatus('üîÑ Chargement de la playlist M3U...', 'success');
            
            // Utiliser CORS proxy si n√©cessaire
            const proxyUrl = 'https://cors-anywhere.herokuapp.com/';
            const fetchUrl = url.startsWith('http://') ? proxyUrl + url : url;
            
            try {
                const response = await fetch(fetchUrl);
                const text = await response.text();
                
                channels = parseM3U(text);
                displayChannels();
                showPlayer();
                showStatus(`‚úÖ ${channels.length} cha√Ænes charg√©es !`, 'success');
            } catch (error) {
                // Si CORS proxy √©choue, essayer direct
                try {
                    const response = await fetch(url);
                    const text = await response.text();
                    channels = parseM3U(text);
                    displayChannels();
                    showPlayer();
                    showStatus(`‚úÖ ${channels.length} cha√Ænes charg√©es !`, 'success');
                } catch (err) {
                    showStatus('‚ùå Impossible de charger la playlist. V√©rifiez l\'URL.', 'error');
                }
            }
        }
        
        function parseM3U(text) {
            const lines = text.split('\n');
            const parsed = [];
            let current = {};
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (line.startsWith('#EXTINF:')) {
                    const match = line.match(/,(.+)$/);
                    current.name = match ? match[1].trim() : 'Cha√Æne ' + (parsed.length + 1);
                } else if (line && !line.startsWith('#')) {
                    current.url = line;
                    if (current.name) {
                        parsed.push({...current});
                    }
                    current = {};
                }
            }
            
            return parsed;
        }
        
        async function loadXtream(config) {
            debugLog('üíâ loadXtream() appel√©', 'info');
            showStatus('üîÑ Connexion au serveur Xtream Codes...', 'success');
            
            let serverUrl = config.url.trim();
            debugLog(`üßπ URL originale: ${serverUrl}`, 'info');
            
            if (serverUrl.endsWith('/')) {
                serverUrl = serverUrl.slice(0, -1);
                debugLog(`üßπ URL nettoy√©e (/ retir√©): ${serverUrl}`, 'info');
            }
            
            const apiUrl = `${serverUrl}/player_api.php?username=${encodeURIComponent(config.username)}&password=${encodeURIComponent(config.password)}&action=get_live_streams`;
            const safeApiUrl = apiUrl.replace(config.password, '***').replace(encodeURIComponent(config.password), '***');
            
            debugLog(`üîó URL API construite: ${safeApiUrl}`, 'info');
            
            const startTime = Date.now();
            
            try {
                debugLog('üîÑ √âTAPE 1/3: Tentative de connexion directe au serveur...', 'info');
                showStatus('üîÑ √âtape 1/3: Connexion au serveur...', 'success');
                
                let response;
                let data;
                let usedProxy = false;
                
                try {
                    debugLog(`üéØ Envoi requ√™te GET vers le serveur...`, 'info');
                    
                    response = await fetch(apiUrl, {
                        method: 'GET',
                        headers: { 'Accept': 'application/json' }
                    });
                    
                    const elapsed = Date.now() - startTime;
                    debugLog(`‚è±Ô∏è R√©ponse re√ßue en ${elapsed}ms`, 'info');
                    debugLog(`üìä Status HTTP: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
                    debugLog(`üì¶ Content-Type: ${response.headers.get('content-type')}`, 'info');
                    
                    if (!response.ok) {
                        debugLog(`‚ùå Erreur HTTP ${response.status}`, 'error');
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const text = await response.text();
                    debugLog(`üìù Longueur r√©ponse: ${text.length} caract√®res`, 'info');
                    debugLog(`üì• Aper√ßu r√©ponse: ${text.substring(0, 200)}${text.length > 200 ? '...' : ''}`, 'info');
                    
                    try {
                        data = JSON.parse(text);
                        debugLog(`‚úÖ JSON pars√© avec succ√®s`, 'success');
                    } catch (e) {
                        debugLog(`‚ùå ERREUR parsing JSON: ${e.message}`, 'error');
                        throw new Error('La r√©ponse n\'est pas du JSON valide: ' + text.substring(0, 100));
                    }
                    
                } catch (directError) {
                    debugLog(`‚ö†Ô∏è Connexion directe √©chou√©e: ${directError.message}`, 'warning');
                    debugLog(`üîÑ √âTAPE 2/3: Tentative avec proxy CORS...`, 'info');
                    showStatus('üîÑ √âtape 2/3: Utilisation du proxy CORS...', 'success');
                    
                    const proxyUrl = 'https://api.allorigins.win/raw?url=';
                    const proxiedUrl = proxyUrl + encodeURIComponent(apiUrl);
                    debugLog(`üåê Proxy utilis√©: api.allorigins.win`, 'info');
                    
                    try {
                        response = await fetch(proxiedUrl);
                        const elapsed = Date.now() - startTime;
                        debugLog(`‚è±Ô∏è R√©ponse proxy re√ßue en ${elapsed}ms`, 'info');
                        
                        const text = await response.text();
                        debugLog(`üìù Longueur r√©ponse proxy: ${text.length} caract√®res`, 'info');
                        
                        data = JSON.parse(text);
                        usedProxy = true;
                        debugLog(`‚úÖ Connexion via proxy r√©ussie`, 'success');
                    } catch (proxyError) {
                        debugLog(`‚ùå ERREUR proxy: ${proxyError.message}`, 'error');
                        throw new Error(`Proxy aussi √©chou√©: ${proxyError.message}`);
                    }
                }
                
                debugLog(`üîÑ √âTAPE 3/3: Analyse et traitement des donn√©es...`, 'info');
                showStatus('üîÑ √âtape 3/3: Traitement des cha√Ænes...', 'success');
                
                debugLog(`üîç Type de donn√©es re√ßues: ${Array.isArray(data) ? 'Array' : typeof data}`, 'info');
                
                let streamsList = [];
                
                if (Array.isArray(data)) {
                    streamsList = data;
                    debugLog(`‚úÖ Format d√©tect√©: Array direct de ${streamsList.length} √©l√©ments`, 'success');
                } else if (data && typeof data === 'object') {
                    debugLog(`üîç Cl√©s de l'objet: ${Object.keys(data).join(', ')}`, 'info');
                    
                    if (data.streams && Array.isArray(data.streams)) {
                        streamsList = data.streams;
                        debugLog(`‚úÖ Format d√©tect√©: data.streams avec ${streamsList.length} cha√Ænes`, 'success');
                    } else if (data.data && Array.isArray(data.data)) {
                        streamsList = data.data;
                        debugLog(`‚úÖ Format d√©tect√©: data.data avec ${streamsList.length} cha√Ænes`, 'success');
                    } else {
                        if (data.user_info) {
                            debugLog(`üë§ Info utilisateur pr√©sente:`, 'info');
                            debugLog(`   - Username: ${data.user_info.username || 'N/A'}`, 'info');
                            debugLog(`   - Status: ${data.user_info.status || 'N/A'}`, 'info');
                            debugLog(`   - Exp date: ${data.user_info.exp_date || 'N/A'}`, 'info');
                            debugLog(`‚ùå Aucune cha√Æne disponible pour cet abonnement`, 'error');
                            throw new Error('Aucune cha√Æne disponible pour cet abonnement');
                        }
                        debugLog(`‚ùå Format de r√©ponse non reconnu`, 'error');
                        throw new Error('Format de r√©ponse inattendu: ' + JSON.stringify(data).substring(0, 100));
                    }
                } else {
                    debugLog(`‚ùå Type de donn√©es invalide: ${typeof data}`, 'error');
                    throw new Error('Donn√©es invalides re√ßues du serveur');
                }
                
                if (streamsList.length === 0) {
                    debugLog(`‚ùå Liste de cha√Ænes vide`, 'error');
                    throw new Error('Aucune cha√Æne trouv√©e sur ce serveur');
                }
                
                debugLog(`‚úÖ ${streamsList.length} cha√Ænes trouv√©es dans la r√©ponse`, 'success');
                
                if (streamsList.length > 0) {
                    const first = streamsList[0];
                    debugLog(`üì¶ Exemple 1√®re cha√Æne:`, 'info');
                    debugLog(`   - stream_id: ${first.stream_id || first.id || 'N/A'}`, 'info');
                    debugLog(`   - name: ${first.name || first.stream_display_name || 'N/A'}`, 'info');
                    debugLog(`   - category: ${first.category_name || first.category || 'N/A'}`, 'info');
                }
                
                debugLog(`üõ†Ô∏è Mapping des cha√Ænes...`, 'info');
                
                channels = streamsList.map((ch, index) => {
                    const streamId = ch.stream_id || ch.id || ch.num;
                    const channelName = ch.name || ch.stream_display_name || ch.title || `Cha√Æne ${streamId}`;
                    const categoryName = ch.category_name || ch.category || '';
                    
                    if (index < 3) {
                        debugLog(`   [${index + 1}] ${channelName} (ID: ${streamId})`, 'info');
                    }
                    
                    return {
                        name: channelName,
                        url: `${serverUrl}/live/${config.username}/${config.password}/${streamId}.m3u8`,
                        category: categoryName,
                        streamId: streamId
                    };
                });
                
                if (streamsList.length > 3) {
                    debugLog(`   ... et ${streamsList.length - 3} autres cha√Ænes`, 'info');
                }
                
                const totalTime = Date.now() - startTime;
                debugLog(`‚è±Ô∏è Temps total de traitement: ${totalTime}ms`, 'success');
                debugLog(`‚úÖ ${channels.length} cha√Ænes mapp√©es avec succ√®s`, 'success');
                
                displayChannels();
                showPlayer();
                
                const successMsg = `‚úÖ ${channels.length} cha√Ænes Xtream charg√©es ${usedProxy ? '(via proxy)' : '(direct)'} !`;
                showStatus(successMsg, 'success');
                debugLog(successMsg, 'success');
                
            } catch (error) {
                const totalTime = Date.now() - startTime;
                debugLog(`‚ùå ERREUR FATALE apr√®s ${totalTime}ms`, 'error');
                debugLog(`‚ùå Type d'erreur: ${error.name}`, 'error');
                debugLog(`‚ùå Message: ${error.message}`, 'error');
                
                if (error.stack) {
                    debugLog(`üîç Stack trace:`, 'error');
                    error.stack.split('\n').slice(0, 3).forEach(line => {
                        debugLog(`   ${line.trim()}`, 'error');
                    });
                }
                
                let errorMessage = '‚ùå Erreur Xtream: ';
                let userTip = '';
                
                if (error.message.includes('Failed to fetch')) {
                    errorMessage += 'Impossible de contacter le serveur.';
                    userTip = 'üí° V√©rifiez: 1) L\'URL du serveur, 2) Votre connexion Internet, 3) Le serveur est en ligne';
                    debugLog(userTip, 'warning');
                } else if (error.message.includes('HTTP 401') || error.message.includes('Unauthorized')) {
                    errorMessage += 'Identifiants incorrects.';
                    userTip = 'üí° V√©rifiez: 1) Nom d\'utilisateur correct, 2) Mot de passe correct, 3) Pas d\'espaces en trop';
                    debugLog(userTip, 'warning');
                } else if (error.message.includes('HTTP 403') || error.message.includes('Forbidden')) {
                    errorMessage += 'Acc√®s refus√©.';
                    userTip = 'üí° V√©rifiez: 1) Abonnement valide, 2) Pas expir√©, 3) Connexions simultan√©es limit√©es';
                    debugLog(userTip, 'warning');
                } else if (error.message.includes('HTTP 404')) {
                    errorMessage += 'Serveur introuvable.';
                    userTip = 'üí° V√©rifiez: 1) URL compl√®te avec port, 2) Pas de faute de frappe, 3) Serveur utilise bien Xtream API';
                    debugLog(userTip, 'warning');
                } else if (error.message.includes('JSON')) {
                    errorMessage += 'R√©ponse invalide du serveur.';
                    userTip = 'üí° Le serveur ne semble pas √™tre un serveur Xtream Codes valide';
                    debugLog(userTip, 'warning');
                } else if (error.message.includes('Aucune cha√Æne')) {
                    errorMessage += error.message;
                    userTip = 'üí° Votre abonnement ne contient aucune cha√Æne live';
                    debugLog(userTip, 'warning');
                } else {
                    errorMessage += error.message;
                }
                
                showStatus(errorMessage, 'error');
                debugLog(`üíî √âchec total du chargement Xtream`, 'error');
            }
        }
        
        function displayChannels() {
            const container = document.getElementById('channelsList');
            container.innerHTML = '';
            
            channels.forEach((channel, index) => {
                const card = document.createElement('div');
                card.className = 'channel-card';
                card.onclick = () => playChannel(channel);
                
                card.innerHTML = `
                    <h3>üì∫ ${channel.name}</h3>
                    ${channel.category ? `<p>${channel.category}</p>` : ''}
                `;
                
                container.appendChild(card);
            });
        }
        
        function filterContent() {
            const search = document.getElementById('searchBox').value.toLowerCase();
            const cards = document.querySelectorAll('.channel-card, .media-card');
            
            cards.forEach(card => {
                const text = card.textContent.toLowerCase();
                card.style.display = text.includes(search) ? 'block' : 'none';
            });
        }
        
        // Charger les films depuis Xtream
        async function loadMovies() {
            if (!channels.length) {
                showStatus('‚ö†Ô∏è Chargez d\'abord les cha√Ænes', 'warning');
                return;
            }
            
            debugLog('üé¨ Chargement des films...', 'info');
            showStatus('üîÑ Chargement des films...', 'success');
            
            const config = JSON.parse(localStorage.getItem('iptvConfig'));
            if (!config || config.type !== 'xtream') {
                showStatus('‚ö†Ô∏è Les films n√©cessitent Xtream Codes', 'warning');
                return;
            }
            
            try {
                let serverUrl = config.url.trim();
                if (serverUrl.endsWith('/')) serverUrl = serverUrl.slice(0, -1);
                
                const apiUrl = `${serverUrl}/player_api.php?username=${encodeURIComponent(config.username)}&password=${encodeURIComponent(config.password)}&action=get_vod_streams`;
                
                const response = await fetch(apiUrl);
                const data = await response.json();
                
                movies = Array.isArray(data) ? data.map((m, i) => ({
                    name: m.name || m.title || `Film ${i+1}`,
                    url: `${serverUrl}/movie/${config.username}/${config.password}/${m.stream_id}.${m.container_extension || 'mp4'}`,
                    category: m.category_name || 'Films',
                    poster: m.stream_icon || m.cover_big || null,
                    streamId: m.stream_id
                })) : [];
                
                debugLog(`‚úÖ ${movies.length} films charg√©s`, 'success');
                displayMovies();
            } catch (error) {
                debugLog(`‚ùå Erreur chargement films: ${error.message}`, 'error');
                showStatus('‚ùå Impossible de charger les films', 'error');
            }
        }
        
        function displayMovies() {
            const container = document.getElementById('moviesList');
            container.innerHTML = '';
            
            if (movies.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #94a3b8; padding: 40px;">Aucun film disponible</p>';
                return;
            }
            
            movies.forEach(movie => {
                const card = createMediaCard(movie);
                container.appendChild(card);
            });
        }
        
        // Charger les s√©ries depuis Xtream
        async function loadSeries() {
            if (!channels.length) {
                showStatus('‚ö†Ô∏è Chargez d\'abord les cha√Ænes', 'warning');
                return;
            }
            
            debugLog('üì∫ Chargement des s√©ries...', 'info');
            showStatus('üîÑ Chargement des s√©ries...', 'success');
            
            const config = JSON.parse(localStorage.getItem('iptvConfig'));
            if (!config || config.type !== 'xtream') {
                showStatus('‚ö†Ô∏è Les s√©ries n√©cessitent Xtream Codes', 'warning');
                return;
            }
            
            try {
                let serverUrl = config.url.trim();
                if (serverUrl.endsWith('/')) serverUrl = serverUrl.slice(0, -1);
                
                const apiUrl = `${serverUrl}/player_api.php?username=${encodeURIComponent(config.username)}&password=${encodeURIComponent(config.password)}&action=get_series`;
                
                const response = await fetch(apiUrl);
                const data = await response.json();
                
                series = Array.isArray(data) ? data.map((s, i) => ({
                    name: s.name || s.title || `S√©rie ${i+1}`,
                    url: `${serverUrl}/series/${config.username}/${config.password}/${s.series_id}.m3u8`,
                    category: s.category_name || 'S√©ries',
                    poster: s.cover || s.cover_big || null,
                    seriesId: s.series_id
                })) : [];
                
                debugLog(`‚úÖ ${series.length} s√©ries charg√©es`, 'success');
                displaySeries();
            } catch (error) {
                debugLog(`‚ùå Erreur chargement s√©ries: ${error.message}`, 'error');
                showStatus('‚ùå Impossible de charger les s√©ries', 'error');
            }
        }
        
        function displaySeries() {
            const container = document.getElementById('seriesList');
            container.innerHTML = '';
            
            if (series.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #94a3b8; padding: 40px;">Aucune s√©rie disponible</p>';
                return;
            }
            
            series.forEach(serie => {
                const card = createMediaCard(serie);
                container.appendChild(card);
            });
        }
        
        // Charger l'EPG (Electronic Program Guide)
        async function loadEPG() {
            debugLog('üìã Chargement de l\'EPG...', 'info');
            showStatus('üîÑ Chargement du guide des programmes...', 'success');
            
            const config = JSON.parse(localStorage.getItem('iptvConfig'));
            
            try {
                // G√©n√©rer un EPG fictif avec horaires r√©alistes
                const now = new Date();
                epgData = channels.slice(0, 10).flatMap((channel, index) => {
                    const programs = [];
                    let startTime = new Date(now);
                    startTime.setHours(6, 0, 0, 0);
                    
                    const programTemplates = [
                        { title: 'Journal du matin', duration: 30 },
                        { title: 'M√©t√©o', duration: 15 },
                        { title: 'Magazine', duration: 60 },
                        { title: 'Film', duration: 120 },
                        { title: 'S√©rie', duration: 45 },
                        { title: 'Documentaire', duration: 60 },
                        { title: 'Journal du soir', duration: 30 },
                        { title: 'Divertissement', duration: 90 }
                    ];
                    
                    for (let i = 0; i < 8; i++) {
                        const template = programTemplates[i];
                        const endTime = new Date(startTime.getTime() + template.duration * 60000);
                        const isCurrent = now >= startTime && now < endTime;
                        
                        programs.push({
                            channel: channel.name,
                            title: template.title,
                            start: startTime.toISOString(),
                            end: endTime.toISOString(),
                            description: `${template.title} sur ${channel.name}`,
                            isCurrent: isCurrent
                        });
                        
                        startTime = new Date(endTime);
                    }
                    
                    return programs;
                });
                
                debugLog(`‚úÖ EPG g√©n√©r√©: ${epgData.length} programmes`, 'success');
                displayEPG();
            } catch (error) {
                debugLog(`‚ùå Erreur chargement EPG: ${error.message}`, 'error');
                showStatus('‚ùå Impossible de charger l\'EPG', 'error');
            }
        }
        
        function displayEPG() {
            const container = document.getElementById('epgTimeline');
            container.innerHTML = '';
            
            if (epgData.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #94a3b8; padding: 40px;">Aucun programme disponible</p>';
                return;
            }
            
            // Grouper par cha√Æne
            const byChannel = {};
            epgData.forEach(prog => {
                if (!byChannel[prog.channel]) byChannel[prog.channel] = [];
                byChannel[prog.channel].push(prog);
            });
            
            // Afficher les programmes actuels et √† venir
            Object.entries(byChannel).forEach(([channel, programs]) => {
                const now = new Date();
                const upcoming = programs.filter(p => new Date(p.start) >= now).slice(0, 3);
                
                upcoming.forEach(prog => {
                    const card = document.createElement('div');
                    card.className = `epg-program ${prog.isCurrent ? 'current' : ''}`;
                    
                    const start = new Date(prog.start);
                    const end = new Date(prog.end);
                    
                    card.innerHTML = `
                        <div class="epg-time">
                            ${start.toLocaleTimeString('fr-FR', {hour: '2-digit', minute: '2-digit'})} - 
                            ${end.toLocaleTimeString('fr-FR', {hour: '2-digit', minute: '2-digit'})}
                            ${prog.isCurrent ? '<span style="color: #22c55e; margin-left: 8px;">‚óè EN DIRECT</span>' : ''}
                        </div>
                        <div class="epg-title">${prog.title}</div>
                        <div class="epg-description">${channel}</div>
                    `;
                    
                    container.appendChild(card);
                });
            });
        }
        
        function playChannel(channel) {
            const video = document.getElementById('videoPlayer');
            const container = document.getElementById('videoContainer');
            const playing = document.getElementById('currentPlaying');
            const playingName = document.getElementById('playingName');
            
            container.classList.remove('hidden');
            playing.classList.remove('hidden');
            playingName.textContent = channel.name;
            
            debugLog(`üé¨ Lecture de: ${channel.name}`, 'info');
            debugLog(`üîó URL: ${channel.url.substring(0, 80)}...`, 'info');
            
            // Arr√™ter HLS pr√©c√©dent
            if (hls) {
                debugLog('üõë Arr√™t du stream pr√©c√©dent', 'info');
                hls.destroy();
                hls = null;
            }
            
            // R√©initialiser le player
            video.pause();
            video.removeAttribute('src');
            video.load();
            
            // D√©tecter si c'est HLS (.m3u8)
            if (channel.url.includes('.m3u8')) {
                debugLog('üì° Format d√©tect√©: HLS (M3U8)', 'info');
                
                // V√©rifier support natif HLS (Safari, certains navigateurs Android)
                if (video.canPlayType('application/vnd.apple.mpegurl')) {
                    debugLog('‚úÖ Support HLS natif du navigateur', 'success');
                    video.src = channel.url;
                    video.play().catch(e => {
                        debugLog(`‚ùå Erreur lecture native: ${e.message}`, 'error');
                    });
                }
                // Sinon utiliser HLS.js (Chrome, Firefox, etc.)
                else if (Hls.isSupported()) {
                    debugLog('‚úÖ Utilisation de HLS.js', 'success');
                    
                    // Configuration optimis√©e pour Android/XPENG (hardware decode)
                    const hlsConfig = {
                        enableWorker: true,
                        lowLatencyMode: false,
                        backBufferLength: 90,
                        maxBufferLength: 30,
                        maxMaxBufferLength: 60,
                        maxBufferSize: 60 * 1000 * 1000,
                        maxBufferHole: 0.5,
                        highBufferWatchdogPeriod: 2,
                        nudgeOffset: 0.1,
                        nudgeMaxRetry: 3,
                        maxFragLookUpTolerance: 0.25,
                        liveSyncDurationCount: 3,
                        liveMaxLatencyDurationCount: 10,
                        liveDurationInfinity: false,
                        preferManagedMediaSource: false,
                        // Forcer le d√©codage hardware si possible
                        abrEwmaDefaultEstimate: 500000
                    };
                    
                    hls = new Hls(hlsConfig);
                    
                    hls.on(Hls.Events.MEDIA_ATTACHED, () => {
                        debugLog('üì∫ HLS attach√© au player', 'success');
                    });
                    
                    hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
                        debugLog(`‚úÖ Manifest pars√©: ${data.levels.length} qualit√©s disponibles`, 'success');
                        video.play().catch(e => {
                            debugLog(`‚ùå Erreur autoplay: ${e.message}`, 'error');
                        });
                    });
                    
                    hls.on(Hls.Events.ERROR, (event, data) => {
                        if (data.fatal) {
                            debugLog(`‚ùå Erreur HLS fatale: ${data.type} - ${data.details}`, 'error');
                            switch (data.type) {
                                case Hls.ErrorTypes.NETWORK_ERROR:
                                    debugLog('üîÑ Tentative de r√©cup√©ration r√©seau...', 'warning');
                                    hls.startLoad();
                                    break;
                                case Hls.ErrorTypes.MEDIA_ERROR:
                                    debugLog('üîÑ Tentative de r√©cup√©ration m√©dia...', 'warning');
                                    hls.recoverMediaError();
                                    break;
                                default:
                                    debugLog('üíî Impossible de r√©cup√©rer, destruction HLS', 'error');
                                    hls.destroy();
                                    break;
                            }
                        } else {
                            debugLog(`‚ö†Ô∏è Erreur HLS non-fatale: ${data.details}`, 'warning');
                        }
                    });
                    
                    hls.loadSource(channel.url);
                    hls.attachMedia(video);
                } else {
                    debugLog('‚ùå HLS non support√© par ce navigateur', 'error');
                    showStatus('‚ùå Format HLS non support√© par votre navigateur', 'error');
                }
            } 
            // Formats directs (MP4, WebM, etc.)
            else {
                debugLog('üìπ Format d√©tect√©: Vid√©o directe (MP4/WebM)', 'info');
                video.src = channel.url;
                video.play().catch(e => {
                    debugLog(`‚ùå Erreur lecture: ${e.message}`, 'error');
                    showStatus('‚ùå Impossible de lire cette vid√©o', 'error');
                });
            }
            
            // √âv√©nements vid√©o
            video.addEventListener('loadstart', () => debugLog('‚è≥ Chargement...', 'info'), { once: true });
            video.addEventListener('canplay', () => debugLog('‚úÖ Vid√©o pr√™te', 'success'), { once: true });
            video.addEventListener('playing', () => debugLog('‚ñ∂Ô∏è Lecture en cours', 'success'), { once: true });
            video.addEventListener('waiting', () => debugLog('‚è∏Ô∏è Buffering...', 'warning'), { once: true });
            video.addEventListener('error', (e) => {
                debugLog(`‚ùå Erreur vid√©o: ${e.target.error?.message || 'Unknown'}`, 'error');
            }, { once: true });
            
            // Scroll vers le player
            setTimeout(() => {
                container.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 300);
        }
        
        function showPlayer() {
            document.getElementById('setupSection').classList.add('hidden');
            document.getElementById('playerSection').classList.remove('hidden');
        }
        
        function showSetup() {
            document.getElementById('setupSection').classList.remove('hidden');
            document.getElementById('playerSection').classList.add('hidden');
        }
        
        function showStatus(message, type) {
            const status = document.getElementById('statusMessage');
            status.textContent = message;
            status.className = 'status-message status-' + type;
            status.style.display = 'block';
            
            setTimeout(() => {
                status.style.display = 'none';
            }, 5000);
        }
        
        function clearStorage() {
            if (confirm('Voulez-vous vraiment effacer toutes les donn√©es sauvegard√©es ?')) {
                localStorage.removeItem('iptvConfig');
                location.reload();
            }
        }
    </script>
</body>
</html>
