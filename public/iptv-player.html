<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>XPENG IPTV Player - Web App</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #f1f5f9;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 16px;
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            font-size: 2rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #06b6d4, #3b82f6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            overflow-x: auto;
            padding-bottom: 4px;
        }
        
        .tab {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            white-space: nowrap;
            font-size: 14px;
            font-weight: 500;
        }
        
        .tab:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateY(-2px);
        }
        
        .tab.active {
            background: linear-gradient(135deg, #06b6d4, #3b82f6);
            border-color: transparent;
            box-shadow: 0 4px 12px rgba(6, 182, 212, 0.3);
        }
        
        .content-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 18px;
            margin-top: 20px;
        }
        
        .media-card {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .media-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            border-color: rgba(6, 182, 212, 0.5);
        }
        
        .media-card img {
            width: 100%;
            height: 240px;
            object-fit: cover;
            background: linear-gradient(135deg, #1e293b, #334155);
        }
        
        .media-card .info {
            padding: 12px;
        }
        
        .media-card .title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 4px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .media-card .category {
            font-size: 12px;
            color: #94a3b8;
        }
        
        .favorite-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.6);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s;
        }
        
        .favorite-btn:hover {
            background: rgba(239, 68, 68, 0.8);
            transform: scale(1.1);
        }
        
        .favorite-btn.active {
            background: rgba(239, 68, 68, 0.9);
        }
        
        .epg-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .epg-timeline {
            display: flex;
            gap: 16px;
            overflow-x: auto;
            padding-bottom: 16px;
        }
        
        .epg-program {
            min-width: 300px;
            background: rgba(255, 255, 255, 0.08);
            padding: 16px;
            border-radius: 8px;
            border-left: 4px solid #06b6d4;
        }
        
        .epg-program.current {
            border-left-color: #22c55e;
            background: rgba(34, 197, 94, 0.1);
        }
        
        .epg-time {
            font-size: 12px;
            color: #94a3b8;
            margin-bottom: 4px;
        }
        
        .epg-title {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
        }
        
        .epg-description {
            font-size: 13px;
            color: #cbd5e1;
            line-height: 1.4;
        }
        
        .setup-form, .player-section {
            background: rgba(255, 255, 255, 0.08);
            padding: 30px;
            border-radius: 16px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 20px;
        }
        
        .form-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #cbd5e1;
        }
        
        input, select {
            width: 100%;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #f1f5f9;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #06b6d4;
            background: rgba(255, 255, 255, 0.15);
        }

        textarea {
            width: 100%;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #f1f5f9;
            font-size: 13px;
            min-height: 140px;
            resize: vertical;
        }

        textarea:focus {
            outline: none;
            border-color: #06b6d4;
            background: rgba(255, 255, 255, 0.15);
        }
        
        button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #06b6d4, #3b82f6);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 25px rgba(6, 182, 212, 0.4);
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            margin-left: 10px;
        }
        
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .channels-grid {
            display: grid;
            /* Mosa√Øque par d√©faut: cartes plus compactes pour permettre plusieurs colonnes sur √©cran XPENG */
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 22px;
        }
        
        .channel-card {
            position: relative;
            background: rgba(15, 23, 42, 0.9);
            padding: 20px;
            border-radius: 16px;
            cursor: pointer;
            transition: all 0.3s;
            border: 1px solid rgba(148, 163, 184, 0.35);
            box-shadow: 0 14px 30px rgba(15, 23, 42, 0.6);
        }
        
        .channel-card:hover {
            background: rgba(30, 64, 175, 0.9);
            transform: translateY(-3px);
            border-color: #3b82f6;
        }
        
        .channel-card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-style: dashed;
        }
        
        .channel-card.disabled:hover {
            background: rgba(15, 23, 42, 0.9);
            transform: none;
            border-color: rgba(148, 163, 184, 0.35);
        }
        
        .channel-compat {
            margin-top: 6px;
            font-size: 11px;
        }
        
        .channel-compat-ok {
            color: #4ade80;
        }
        
        .channel-compat-warning {
            color: #facc15;
        }
        
        .channel-compat-bad {
            color: #fca5a5;
        }
        
        .channel-card h3 {
            font-size: 18px;
            margin-bottom: 6px;
            color: #f9fafb;
        }
        
        .channel-card p {
            font-size: 13px;
            color: #cbd5e1;
        }
        
        .video-player {
            margin-top: 20px;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
        }
        
        video {
            width: 100%;
            max-height: 600px;
        }
        
        .hidden {
            display: none;
        }
        
        .status-message {
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        .status-success {
            background: rgba(34, 197, 94, 0.2);
            border: 1px solid rgba(34, 197, 94, 0.5);
            color: #86efac;
        }
        
        .status-error {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.5);
            color: #fca5a5;
        }

        .status-warning {
            background: rgba(234, 179, 8, 0.18);
            border: 1px solid rgba(234, 179, 8, 0.55);
            color: #facc15;
        }

        .status-info {
            background: rgba(59, 130, 246, 0.18);
            border: 1px solid rgba(59, 130, 246, 0.55);
            color: #bfdbfe;
        }

        .debug-panel {
            margin-top: 12px;
            padding: 10px 14px;
            border-radius: 10px;
            background: rgba(15, 23, 42, 0.95);
            border: 1px solid rgba(148, 163, 184, 0.6);
            font-size: 11px;
            max-height: 150px;
            overflow-y: auto;
            line-height: 1.4;
        }

        .debug-line {
            margin-bottom: 2px;
            white-space: pre-wrap;
            word-break: break-word;
        }

        .debug-info { color: #e5e7eb; }
        .debug-success { color: #bbf7d0; }
        .debug-warning { color: #facc15; }
        .debug-error { color: #fecaca; }
        
        .search-box {
            width: 100%;
            padding: 12px 16px;
            margin-bottom: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #f1f5f9;
            font-size: 14px;
        }
        
        .current-playing {
            background: rgba(6, 182, 212, 0.2);
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
            border: 1px solid #06b6d4;
        }

        .view-switcher {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: flex-end;
            margin: 8px 0 12px;
        }

        .view-btn {
            padding: 6px 10px;
            font-size: 11px;
            border-radius: 999px;
            border: 1px solid rgba(148, 163, 184, 0.5);
            background: rgba(15, 23, 42, 0.7);
            color: #cbd5e1;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            transition: all 0.2s ease;
        }

        .view-btn:hover {
            background: rgba(30, 64, 175, 0.7);
            border-color: #3b82f6;
            color: #e5f2ff;
        }

        .view-btn.active {
            background: linear-gradient(135deg, #06b6d4, #3b82f6);
            border-color: transparent;
            color: #f9fafb;
            box-shadow: 0 6px 18px rgba(37, 99, 235, 0.4);
        }

        /* Layout: mosa√Øque (par d√©faut) */
        #playerSection[data-layout="grid"] .channels-grid,
        #playerSection[data-layout="grid"] .content-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 16px;
        }

        /* Layout: liste / d√©tail - cartes pleine largeur en ligne */
        #playerSection[data-layout="list"] .channels-grid,
        #playerSection[data-layout="detail"] .channels-grid,
        #playerSection[data-layout="list"] .content-grid,
        #playerSection[data-layout="detail"] .content-grid {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        #playerSection[data-layout="list"] .channel-card,
        #playerSection[data-layout="detail"] .channel-card,
        #playerSection[data-layout="list"] .media-card,
        #playerSection[data-layout="detail"] .media-card {
            display: flex;
            align-items: center;
            gap: 14px;
        }

        #playerSection[data-layout="list"] .channel-card h3,
        #playerSection[data-layout="detail"] .channel-card h3 {
            font-size: 15px;
            margin-bottom: 2px;
        }

        #playerSection[data-layout="list"] .media-card img,
        #playerSection[data-layout="detail"] .media-card img {
            width: 120px;
            height: 72px;
            flex-shrink: 0;
        }

        #playerSection[data-layout="list"] .media-card .info,
        #playerSection[data-layout="detail"] .media-card .info {
            padding: 4px 0;
        }

        /* Vue d√©taill√©e : plus d'espace et titres multi-lignes pour les VOD/s√©ries */
        #playerSection[data-layout="detail"] .media-card {
            padding: 12px 14px;
        }

        #playerSection[data-layout="detail"] .media-card .title {
            white-space: normal;
        }

        #playerSection[data-layout="detail"] .media-card .category {
            opacity: 0.9;
        }

        /* Sp√©cifique aux cha√Ænes TV en mode liste : rang√©es plus fines, fond uni */
        #playerSection[data-layout="list"] .channel-card {
            padding: 12px 16px;
            border-radius: 12px;
            background: rgba(15, 23, 42, 0.96);
        }

        /* Sp√©cifique aux cha√Ænes TV en mode d√©tail : cartes plus grandes, fond d√©grad√© */
        #playerSection[data-layout="detail"] .channel-card {
            padding: 16px 18px;
            border-radius: 18px;
            background: linear-gradient(135deg, rgba(30, 64, 175, 0.95), rgba(56, 189, 248, 0.9));
        }

        #playerSection[data-layout="detail"] .channel-card h3 {
            font-size: 17px;
        }

        #playerSection[data-layout="detail"] .channel-card p {
            color: #e2e8f0;
        }

        #playerSection[data-layout="detail"] .channel-compat {
            font-size: 12px;
            white-space: normal;
        }

        /* Vue mini-cards : ultra compacte, id√©ale en conduite (stationnement) */
        #playerSection[data-layout="mini"] .channels-grid,
        #playerSection[data-layout="mini"] .content-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
            gap: 8px;
        }

        #playerSection[data-layout="mini"] .channel-card,
        #playerSection[data-layout="mini"] .media-card {
            padding: 8px 9px;
            border-radius: 10px;
        }

        #playerSection[data-layout="mini"] .channel-card h3,
        #playerSection[data-layout="mini"] .media-card .title {
            font-size: 12px;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #playerSection[data-layout="mini"] .channel-card p,
        #playerSection[data-layout="mini"] .media-card .category {
            font-size: 11px;
        }

        #playerSection[data-layout="mini"] .media-card img {
            display: none;
        }

        /* Mode EPG plein √©cran (body.epg-fullscreen) */
        body.epg-fullscreen {
            background: #020617;
            overflow: hidden;
        }

        body.epg-fullscreen .container {
            max-width: 100%;
            padding: 0;
            border-radius: 0;
        }

        body.epg-fullscreen .header,
        body.epg-fullscreen #setupSection,
        body.epg-fullscreen .tabs,
        body.epg-fullscreen #searchBox,
        body.epg-fullscreen .view-switcher,
        body.epg-fullscreen #currentPlaying,
        body.epg-fullscreen #videoContainer,
        body.epg-fullscreen #sectionLive,
        body.epg-fullscreen #sectionMovies,
        body.epg-fullscreen #sectionSeries,
        body.epg-fullscreen #sectionFavorites,
        body.epg-fullscreen #sectionHistory {
            display: none !important;
        }

        body.epg-fullscreen #playerSection {
            margin-top: 0;
        }

        body.epg-fullscreen #sectionEpg {
            display: block !important;
        }

        body.epg-fullscreen #epgContainer {
            margin: 0;
            border-radius: 0;
            border: none;
            max-width: none;
            height: 100vh;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üé¨ XPENG IPTV Player</h1>
            <p>Web App optimis√©e pour navigateur XPENG</p>
            <p style="font-size: 12px; margin-top: 8px; color: #94a3b8;">‚úÖ Support HLS/M3U8 ‚Ä¢ Hardware Decode ‚Ä¢ Twine4Car Compatible</p>
        </div>
        
        <div id="setupSection" class="setup-form">
            <h2 style="margin-bottom: 20px;">üì° Configuration IPTV</h2>
            
            <div class="form-group">
                <label for="connectionType">Type de connexion :</label>
                <select id="connectionType" onchange="updateFormFields()">
                    <option value="m3u">URL M3U/M3U8</option>
                    <option value="xtream">Xtream Codes API</option>
                </select>
            </div>
            
            <div id="m3uFields">
                <div class="form-group">
                    <label for="m3uUrl">URL de la playlist M3U :</label>
                    <input type="url" id="m3uUrl" placeholder="https://example.com/playlist.m3u8">
                    <small style="display: block; margin-top: 4px; color: #94a3b8; font-size: 11px;">
                        ‚ú® Correction automatique des erreurs de copier-coller (espaces, doubles http, etc.)
                    </small>
                </div>

                <div class="form-group">
                    <label for="m3uPaste">Ou coller directement une playlist M3U :</label>
                    <textarea id="m3uPaste" placeholder="#EXTM3U&#10;#EXTINF:0,Cha√Æne 1&#10;http://exemple.com/stream1.m3u8"></textarea>
                    <small style="display: block; margin-top: 4px; color: #94a3b8; font-size: 11px;">
                        üí° Mode hors-ligne / anti-CORS&nbsp;: aucun t√©l√©chargement distant, le texte est analys√© localement.
                    </small>
                    <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px;">
                        <button type="button" class="btn-secondary" onclick="loadM3UFromText()">
                            üìã Charger depuis le texte coll√©
                        </button>
                        <button type="button" class="btn-secondary" onclick="loadM3UExample()">
                            üß™ Exemple de playlist (demo)
                        </button>
                    </div>
                </div>

                <div class="form-group">
                    <label for="m3uFile">Ou importer un fichier M3U/M3U8 local :</label>
                    <input type="file" id="m3uFile" accept=".m3u,.m3u8,.txt">
                    <small style="display: block; margin-top: 4px; color: #94a3b8; font-size: 11px;">
                        üí° Si le navigateur XPENG autorise l'acc√®s aux fichiers, cela charge la playlist sans passer par Internet.
                    </small>
                    <button type="button" class="btn-secondary" style="margin-top: 8px;" onclick="loadM3UFromFile()">
                        üìÅ Charger le fichier local
                    </button>
                </div>
            </div>
            
            <div id="xtreamFields" class="hidden">
                <div class="form-group">
                    <label for="xtreamUrl">URL du serveur :</label>
                    <input type="url" id="xtreamUrl" placeholder="http://server.com:port">
                    <small style="display: block; margin-top: 4px; color: #94a3b8; font-size: 11px;">
                        ‚ú® Correction automatique des erreurs (espaces, doubles http, httsp, etc.)
                    </small>
                </div>
                <div class="form-group">
                    <label for="xtreamUsername">Nom d'utilisateur :</label>
                    <input type="text" id="xtreamUsername" placeholder="username">
                </div>
                <div class="form-group">
                    <label for="xtreamPassword">Mot de passe :</label>
                    <input type="password" id="xtreamPassword" placeholder="password">
                </div>
            </div>
            
            <button onclick="saveAndConnect()">üíæ Sauvegarder et Charger</button>
            <button class="btn-secondary" onclick="clearStorage()">üóëÔ∏è Effacer les donn√©es</button>

            <!-- Statut visible pendant la configuration -->
            <div id="setupStatus" class="status-message status-info" style="display:none; margin-top:16px;"></div>

            <!-- Journal de debug d√©taill√© (M3U & Xtream) -->
            <div id="setupDebugPanel" class="debug-panel" style="display:none; margin-top:10px;">
                <div class="debug-line debug-info">‚ÑπÔ∏è Journal de debug M3U / Xtream ‚Äî les derni√®res √©tapes s‚Äôaffichent ici.</div>
            </div>
        </div>
        
        <div id="playerSection" class="player-section hidden">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2>üì∫ Contenu IPTV</h2>
                <button class="btn-secondary" onclick="showSetup()">‚öôÔ∏è Configuration</button>
            </div>
            
            <!-- Onglets de navigation -->
            <div class="tabs">
                <div class="tab active" onclick="switchTab('live')" id="tabLive">
                    üì° Direct TV
                </div>
                <div class="tab" onclick="switchTab('movies')" id="tabMovies">
                    üé¨ Films
                </div>
                <div class="tab" onclick="switchTab('series')" id="tabSeries">
                    üì∫ S√©ries
                </div>
                <div class="tab" onclick="switchTab('epg')" id="tabEpg">
                    üìã Guide (EPG)
                </div>
                <div class="tab" onclick="switchTab('favorites')" id="tabFavorites">
                    ‚ù§Ô∏è Favoris
                </div>
                <div class="tab" onclick="switchTab('history')" id="tabHistory">
                    üïê Historique
                </div>
            </div>
            
            <input type="text" id="searchBox" class="search-box" placeholder="üîç Rechercher..." onkeyup="filterContent()">

            <!-- S√©lecteur de vue: mosa√Øque / liste / d√©taill√©e -->
            <div class="view-switcher">
                <button id="btnLayoutGrid" class="view-btn active" onclick="setLayout('grid')">
                    üß± Mosa√Øque
                </button>
                <button id="btnLayoutList" class="view-btn" onclick="setLayout('list')">
                    üìã Liste
                </button>
                <button id="btnLayoutDetail" class="view-btn" onclick="setLayout('detail')">
                    ‚ÑπÔ∏è D√©tail
                </button>
                <button id="btnLayoutMini" class="view-btn" onclick="setLayout('mini')">
                    üìö Mini
                </button>
                <button id="btnEpgFullscreen" class="view-btn" onclick="toggleEpgFullscreen()">
                    üß≠ EPG plein √©cran
                </button>
            </div>

            <div id="statusMessage"></div>
            
            <div id="currentPlaying" class="current-playing hidden">
                <strong>‚ñ∂Ô∏è En cours :</strong> <span id="playingName">-</span>
            </div>
            
            <div id="videoContainer" class="video-player hidden">
                <video id="videoPlayer" 
                       controls 
                       autoplay 
                       playsinline 
                       preload="metadata"
                       webkit-playsinline
                       x-webkit-airplay="allow"
                       style="width: 100%; height: 100%; object-fit: contain;">
                    Votre navigateur ne supporte pas la vid√©o HTML5.
                </video>
            </div>
            
            <!-- Section Live TV -->
            <div id="sectionLive" class="content-section">
                <!-- Pagination en haut -->
                <div id="paginationTop" class="pagination-controls" style="display: none; margin-bottom: 20px; text-align: center;">
                    <button onclick="changePage(1)" style="padding: 8px 16px; margin: 0 5px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer;">‚èÆÔ∏è Premi√®re</button>
                    <button onclick="changePage(currentPage - 1)" style="padding: 8px 16px; margin: 0 5px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer;">‚óÄÔ∏è Pr√©c√©dent</button>
                    <span style="padding: 8px 16px; color: #94a3b8; font-weight: 500;">Page <span id="currentPageTop">1</span> / <span id="totalPagesTop">1</span></span>
                    <button onclick="changePage(currentPage + 1)" style="padding: 8px 16px; margin: 0 5px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer;">‚ñ∂Ô∏è Suivant</button>
                    <button onclick="changePage(totalPages)" style="padding: 8px 16px; margin: 0 5px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer;">‚è≠Ô∏è Derni√®re</button>
                    <span style="margin-left: 15px; color: #64748b; font-size: 14px;">(<span id="channelsCountTop">0</span> cha√Ænes)</span>
                </div>
                
                <div id="channelsList" class="channels-grid"></div>
                
                <!-- Pagination en bas -->
                <div id="paginationBottom" class="pagination-controls" style="display: none; margin-top: 20px; text-align: center;">
                    <button onclick="changePage(1)" style="padding: 8px 16px; margin: 0 5px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer;">‚èÆÔ∏è Premi√®re</button>
                    <button onclick="changePage(currentPage - 1)" style="padding: 8px 16px; margin: 0 5px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer;">‚óÄÔ∏è Pr√©c√©dent</button>
                    <span style="padding: 8px 16px; color: #94a3b8; font-weight: 500;">Page <span id="currentPageBottom">1</span> / <span id="totalPagesBottom">1</span></span>
                    <button onclick="changePage(currentPage + 1)" style="padding: 8px 16px; margin: 0 5px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer;">‚ñ∂Ô∏è Suivant</button>
                    <button onclick="changePage(totalPages)" style="padding: 8px 16px; margin: 0 5px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer;">‚è≠Ô∏è Derni√®re</button>
                    <span style="margin-left: 15px; color: #64748b; font-size: 14px;">(<span id="channelsCountBottom">0</span> cha√Ænes)</span>
                </div>
            </div>
            
            <!-- Section Films -->
            <div id="sectionMovies" class="content-section hidden">
                <div id="moviesList" class="content-grid"></div>
            </div>
            
            <!-- Section S√©ries -->
            <div id="sectionSeries" class="content-section hidden">
                <div id="seriesList" class="content-grid"></div>
            </div>
            
            <!-- Section EPG -->
            <div id="sectionEpg" class="content-section hidden">
                <div id="epgContainer" class="epg-container">
                    <h3 style="margin-bottom: 16px;">üìã Guide des programmes</h3>
                    <div id="epgTimeline" class="epg-timeline"></div>
                </div>
            </div>
            
            <!-- Section Favoris -->
            <div id="sectionFavorites" class="content-section hidden">
                <div id="favoritesList" class="content-grid"></div>
            </div>
            
            <!-- Section Historique -->
            <div id="sectionHistory" class="content-section hidden">
                <div id="historyList" class="content-grid"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
    <script>
        // Variables globales
        let channels = [];
        let movies = [];
        let series = [];
        let epgData = [];
        let favorites = JSON.parse(localStorage.getItem('iptvFavorites') || '[]');
        let history = JSON.parse(localStorage.getItem('iptvHistory') || '[]');
        let hls = null;
        let currentTab = 'live';
        let currentLayout = 'grid';
        
        // ‚ö° Configuration du proxy Cloudflare Worker (optionnel)
        // Pour activer, d√©ploie le worker et remplace null par l'URL :
        // Exemple: 'https://xpengmedia-iptv-proxy.VOTRE-ID.workers.dev'
        const CLOUDFLARE_PROXY = null;
        
        // üé¨ Proxifier les URLs de streaming (n√©cessaire si erreur CORS/manifestLoadError)
        const PROXY_STREAMS = true; // Active le proxy pour les flux vid√©o
        
        // üîÑ Liste des proxies de streaming (test√©s automatiquement dans l'ordre)
        const STREAM_PROXIES = [
            { name: 'Cloudflare Worker', url: null, priority: 1 }, // Sera rempli si CLOUDFLARE_PROXY configur√©
            { name: 'cors-anywhere.herokuapp.com', url: 'https://cors-anywhere.herokuapp.com/', priority: 2 },
            { name: 'corsproxy.io', url: 'https://corsproxy.io/?', priority: 3 },
            { name: 'api.codetabs.com', url: 'https://api.codetabs.com/v1/proxy?quest=', priority: 4 },
            { name: 'api.allorigins.win', url: 'https://api.allorigins.win/raw?url=', priority: 5 },
            { name: 'cors.eu.org', url: 'https://cors.eu.org/', priority: 6 }
        ];
        
        let currentStreamProxy = null; // Proxy actuellement utilis√© pour les streams
        let streamProxyRetries = {}; // Compteur d'√©checs par proxy
        
        // üìä Pagination pour gros catalogues (√©vite freeze navigateur)
        const MAX_CHANNELS_PER_PAGE = 100;
        let currentPage = 1;
        let totalPages = 1;
        
        // üíæ Cache intelligent des listes
        const CACHE_DURATION_MS = 30 * 60 * 1000; // 30 minutes
        
        // üîÑ D√©tection automatique du meilleur proxy
        let bestProxy = null;
        let usedProxyForApi = null; // M√©moriser quel proxy a fonctionn√© pour l'API
        
        // ‚ö° Lazy loading pour performance
        let isLoading = false;
        
        // Charger la configuration sauvegard√©e au d√©marrage
        window.onload = function() {
            loadSavedConfig();
            loadFavorites();
            loadHistory();
            // Layout par d√©faut
            setLayout(currentLayout);
        };

        // Gestion des vues (mosa√Øque, liste, d√©taill√©e)
        function setLayout(layout) {
            currentLayout = layout;
            const playerSection = document.getElementById('playerSection');
            if (playerSection) {
                playerSection.setAttribute('data-layout', layout);
            }

            const buttons = {
                grid: document.getElementById('btnLayoutGrid'),
                list: document.getElementById('btnLayoutList'),
                detail: document.getElementById('btnLayoutDetail'),
                mini: document.getElementById('btnLayoutMini'),
            };

            Object.entries(buttons).forEach(([key, btn]) => {
                if (!btn) return;
                if (key === layout) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            debugLog(`üîÄ Layout chang√©: ${layout}`, 'info');
        }

        // Mode EPG plein √©cran (toggle sur le body)
        function toggleEpgFullscreen() {
            // Forcer l'onglet EPG actif
            if (currentTab !== 'epg') {
                switchTab('epg');
            }
            const isNowFull = document.body.classList.toggle('epg-fullscreen');
            const btn = document.getElementById('btnEpgFullscreen');
            if (btn) {
                btn.textContent = isNowFull ? '‚§µÔ∏è Quitter EPG plein √©cran' : 'üß≠ EPG plein √©cran';
            }
            debugLog(isNowFull ? 'üß≠ EPG plein √©cran activ√©' : '‚§µÔ∏è EPG plein √©cran d√©sactiv√©', 'info');
        }
        
        // Gestion des onglets
        function switchTab(tabName) {
            currentTab = tabName;
            
            // Mettre √† jour les onglets actifs
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.getElementById('tab' + tabName.charAt(0).toUpperCase() + tabName.slice(1)).classList.add('active');
            
            // Masquer toutes les sections
            document.querySelectorAll('.content-section').forEach(section => section.classList.add('hidden'));
            
            // Afficher la section active
            document.getElementById('section' + tabName.charAt(0).toUpperCase() + tabName.slice(1)).classList.remove('hidden');
            
            // Charger le contenu si n√©cessaire
            if (tabName === 'movies' && movies.length === 0) {
                loadMovies();
            } else if (tabName === 'series' && series.length === 0) {
                loadSeries();
            } else if (tabName === 'epg' && epgData.length === 0) {
                loadEPG();
            } else if (tabName === 'favorites') {
                displayFavorites();
            } else if (tabName === 'history') {
                displayHistory();
            }
        }
        
        // Ajouter aux favoris
        function toggleFavorite(item) {
            const index = favorites.findIndex(f => f.url === item.url);
            
            if (index > -1) {
                favorites.splice(index, 1);
                debugLog(`‚ùå Retir√© des favoris: ${item.name}`, 'info');
            } else {
                favorites.push({...item, addedAt: Date.now()});
                debugLog(`‚úÖ Ajout√© aux favoris: ${item.name}`, 'success');
            }
            
            localStorage.setItem('iptvFavorites', JSON.stringify(favorites));
            
            // Rafra√Æchir l'affichage
            if (currentTab === 'favorites') {
                displayFavorites();
            }
        }
        
        // Ajouter √† l'historique
        function addToHistory(item) {
            // Retirer l'ancien si existe
            history = history.filter(h => h.url !== item.url);
            
            // Ajouter au d√©but
            history.unshift({...item, watchedAt: Date.now()});
            
            // Garder seulement les 50 derniers
            history = history.slice(0, 50);
            
            localStorage.setItem('iptvHistory', JSON.stringify(history));
            debugLog(`üìù Ajout√© √† l'historique: ${item.name}`, 'info');
        }
        
        // Charger et afficher favoris
        function loadFavorites() {
            favorites = JSON.parse(localStorage.getItem('iptvFavorites') || '[]');
        }
        
        function displayFavorites() {
            const container = document.getElementById('favoritesList');
            container.innerHTML = '';
            
            if (favorites.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #94a3b8; padding: 40px;">Aucun favori. Ajoutez-en en cliquant sur ‚ù§Ô∏è</p>';
                return;
            }
            
            favorites.forEach(item => {
                const card = createMediaCard(item, true);
                container.appendChild(card);
            });
        }
        
        // Charger et afficher historique
        function loadHistory() {
            history = JSON.parse(localStorage.getItem('iptvHistory') || '[]');
        }
        
        function displayHistory() {
            const container = document.getElementById('historyList');
            container.innerHTML = '';
            
            if (history.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #94a3b8; padding: 40px;">Aucun historique</p>';
                return;
            }
            
            history.forEach(item => {
                const card = createMediaCard(item, false, true);
                container.appendChild(card);
            });
        }
        
        // Cr√©er une carte m√©dia (Films/S√©ries)
        function createMediaCard(item, showFavorite = true, showDate = false) {
            const card = document.createElement('div');
            card.className = 'media-card';
            card.style.position = 'relative';
            
            const isFav = favorites.some(f => f.url === item.url);
            
            card.innerHTML = `
                ${showFavorite ? `<button class="favorite-btn ${isFav ? 'active' : ''}" onclick="event.stopPropagation(); toggleFavorite(${JSON.stringify(item).replace(/"/g, '&quot;')})">
                    ${isFav ? '‚ù§Ô∏è' : 'ü§ç'}
                </button>` : ''}
                <img src="${item.poster || 'https://via.placeholder.com/200x300/334155/f1f5f9?text=' + encodeURIComponent(item.name)}" 
                     alt="${item.name}"
                     onerror="this.src='https://via.placeholder.com/200x300/334155/f1f5f9?text=' + encodeURIComponent('${item.name}')">
                <div class="info">
                    <div class="title">${item.name}</div>
                    <div class="category">${item.category || 'Divers'}</div>
                    ${showDate && item.watchedAt ? `<div class="category">${new Date(item.watchedAt).toLocaleDateString('fr-FR')}</div>` : ''}
                </div>
            `;
            
            card.onclick = () => {
                playChannel(item);
                addToHistory(item);
            };
            
            return card;
        }
        
        // Fonction pour logger dans la console ET dans le panneau de debug visible
        function debugLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString('fr-FR');
            const icon = {
                'info': '‚ÑπÔ∏è',
                'success': '‚úÖ',
                'warning': '‚ö†Ô∏è',
                'error': '‚ùå'
            }[type] || '‚ÑπÔ∏è';

            const lineText = `${icon} [${timestamp}] ${message}`;
            console.log(lineText);

            const panel = document.getElementById('setupDebugPanel');
            if (panel) {
                panel.style.display = 'block';
                const div = document.createElement('div');
                div.className = 'debug-line debug-' + type;
                div.textContent = lineText;
                panel.appendChild(div);
                panel.scrollTop = panel.scrollHeight;
            }
        }
        
        let playbackCapabilities = null;

        function getPlaybackCapabilities() {
            if (playbackCapabilities) return playbackCapabilities;

            const testVideo = document.createElement('video');
            const canPlayType = testVideo && typeof testVideo.canPlayType === 'function'
                ? testVideo.canPlayType.bind(testVideo)
                : () => '';

            playbackCapabilities = {
                hlsNative: !!canPlayType('application/vnd.apple.mpegurl'),
                mp4: !!(canPlayType('video/mp4') || canPlayType('video/mp4; codecs="avc1.42E01E, mp4a.40.2"')),
                webm: !!canPlayType('video/webm'),
                hlsJs: typeof Hls !== 'undefined' && typeof Hls.isSupported === 'function' && Hls.isSupported()
            };

            debugLog(
                `üß™ Capacit√©s de lecture d√©tect√©es: HLS natif=${playbackCapabilities.hlsNative ? 'oui' : 'non'}, ` +
                `Hls.js=${playbackCapabilities.hlsJs ? 'oui' : 'non'}, MP4=${playbackCapabilities.mp4 ? 'oui' : 'non'}, ` +
                `WebM=${playbackCapabilities.webm ? 'oui' : 'non'}`,
                'info'
            );

            return playbackCapabilities;
        }

        function evaluateChannelCompatibility(channel) {
            const caps = getPlaybackCapabilities();
            const urlRaw = channel && channel.url ? String(channel.url) : '';
            const url = urlRaw.toLowerCase();

            if (!url) {
                return {
                    supported: false,
                    warning: false,
                    format: 'inconnu',
                    reason: 'URL manquante'
                };
            }

            let format = 'inconnu';
            let supported = true;
            let warning = false;
            let reason = '';

            const isHls = url.includes('.m3u8');
            const isMp4 = url.includes('.mp4');
            const isWebm = url.includes('.webm');
            const isRtmp = url.startsWith('rtmp://');
            const isRtsp = url.startsWith('rtsp://');

            if (isHls) {
                format = 'HLS (.m3u8)';
                if (!caps.hlsNative && !caps.hlsJs) {
                    supported = false;
                    reason = 'HLS non support√© par ce navigateur (ni natif, ni via Hls.js).';
                }
            } else if (isMp4) {
                format = 'MP4';
                if (!caps.mp4) {
                    supported = false;
                    reason = 'Le format MP4 n\'est pas support√© par ce navigateur.';
                }
            } else if (isWebm) {
                format = 'WebM';
                if (!caps.webm) {
                    supported = false;
                    reason = 'Le format WebM n\'est pas support√© par ce navigateur.';
                }
            } else if (isRtmp) {
                format = 'RTMP';
                supported = false;
                reason = 'Le protocole RTMP n\'est pas support√© par les navigateurs HTML5.';
            } else if (isRtsp) {
                format = 'RTSP';
                supported = false;
                reason = 'Le protocole RTSP n\'est pas support√© par les navigateurs HTML5.';
            } else {
                format = 'inconnu';
                warning = true;
                reason = 'Format inconnu, compatibilit√© non garantie.';
            }

            const channelName = channel && channel.name ? channel.name : 'Sans nom';

            if (!supported) {
                debugLog(`‚ö†Ô∏è Cha√Æne probablement non compatible: ${channelName} ‚Äî ${reason}`, 'warning');
            } else if (warning) {
                debugLog(`‚ÑπÔ∏è Cha√Æne au format inconnu: ${channelName} ‚Äî compatibilit√© non garantie.`, 'info');
            } else {
                debugLog(`‚úÖ Cha√Æne marqu√©e compatible (${format}): ${channelName}`, 'success');
            }

            return { supported, warning, format, reason };
        }
        
        function updateFormFields() {
            const type = document.getElementById('connectionType').value;
            document.getElementById('m3uFields').classList.toggle('hidden', type !== 'm3u');
            document.getElementById('xtreamFields').classList.toggle('hidden', type !== 'xtream');
        }
        
        // Fonction intelligente de nettoyage des URLs (erreurs copier-coller Android)
        function smartCleanUrl(url) {
            if (!url) return '';
            
            debugLog(`üßπ Nettoyage URL: "${url}"`, 'info');
            
            // 1. Trim espaces et retours √† la ligne
            let cleaned = url.trim().replace(/[\n\r\t]/g, '');
            
            // 2. Supprimer espaces internes
            cleaned = cleaned.replace(/\s+/g, '');
            
            // 3. Corriger doubles protocoles (httpshttp:// ou httphttp://)
            cleaned = cleaned.replace(/^https?https?:\/\//i, 'http://');
            cleaned = cleaned.replace(/^https?http:\/\//i, 'http://');
            cleaned = cleaned.replace(/^https?https:\/\//i, 'https://');
            
            // 4. Corriger fautes de frappe courantes
            cleaned = cleaned.replace(/^httsp:\/\//i, 'https://');  // httsp
            cleaned = cleaned.replace(/^htttp:\/\//i, 'http://');   // htttp
            cleaned = cleaned.replace(/^htp:\/\//i, 'http://');     // htp
            cleaned = cleaned.replace(/^htps:\/\//i, 'https://');   // htps
            cleaned = cleaned.replace(/^http:\/\/\//i, 'http://');  // triple slash
            cleaned = cleaned.replace(/^https:\/\/\//i, 'https://'); // triple slash
            
            // 5. Supprimer slash en trop √† la fin
            while (cleaned.endsWith('//')) {
                cleaned = cleaned.slice(0, -1);
            }
            
            // 6. Ajouter http:// si manquant (mais contient un domaine)
            if (!cleaned.startsWith('http://') && !cleaned.startsWith('https://')) {
                if (cleaned.includes('.') || cleaned.includes(':')) {
                    debugLog('‚ö†Ô∏è Protocole manquant, ajout de http://', 'warning');
                    cleaned = 'http://' + cleaned;
                }
            }
            
            if (cleaned !== url) {
                debugLog(`‚úÖ URL nettoy√©e: "${cleaned}"`, 'success');
            } else {
                debugLog('‚úÖ URL d√©j√† propre', 'success');
            }
            
            return cleaned;
        }
        
        // Fonction pour tester URL avec fallback HTTP/HTTPS intelligent
        async function smartTestUrl(url) {
            const originalUrl = url;
            
            // Si HTTPS, tester d'abord HTTPS puis fallback HTTP
            if (url.startsWith('https://')) {
                debugLog('üîí Test avec HTTPS...', 'info');
                try {
                    const response = await fetch(url, { method: 'HEAD', timeout: 3000 });
                    if (response.ok) {
                        debugLog('‚úÖ HTTPS fonctionne', 'success');
                        return url;
                    }
                } catch (e) {
                    debugLog('‚ö†Ô∏è HTTPS √©chou√©, tentative HTTP...', 'warning');
                    const httpUrl = url.replace('https://', 'http://');
                    try {
                        const response = await fetch(httpUrl, { method: 'HEAD', timeout: 3000 });
                        if (response.ok) {
                            debugLog('‚úÖ HTTP fonctionne (fallback)', 'success');
                            return httpUrl;
                        }
                    } catch (e2) {
                        debugLog('‚ùå HTTP aussi √©chou√©', 'error');
                    }
                }
            }
            // Si HTTP, tester d'abord HTTP puis essayer HTTPS
            else if (url.startsWith('http://')) {
                debugLog('üîì Test avec HTTP...', 'info');
                try {
                    const response = await fetch(url, { method: 'HEAD', timeout: 3000 });
                    if (response.ok) {
                        debugLog('‚úÖ HTTP fonctionne', 'success');
                        return url;
                    }
                } catch (e) {
                    debugLog('‚ö†Ô∏è HTTP √©chou√©, tentative HTTPS...', 'warning');
                    const httpsUrl = url.replace('http://', 'https://');
                    try {
                        const response = await fetch(httpsUrl, { method: 'HEAD', timeout: 3000 });
                        if (response.ok) {
                            debugLog('‚úÖ HTTPS fonctionne (upgrade)', 'success');
                            return httpsUrl;
                        }
                    } catch (e2) {
                        debugLog('‚ùå HTTPS aussi √©chou√©', 'error');
                    }
                }
            }
            
            // Retourner URL originale si aucun test ne marche
            debugLog('‚ö†Ô∏è Aucun test r√©ussi, utilisation URL originale', 'warning');
            return originalUrl;
        }
        
        function saveAndConnect() {
            // R√©initialiser le panneau de debug √† chaque nouvelle tentative
            const panel = document.getElementById('setupDebugPanel');
            if (panel) {
                panel.style.display = 'block';
                panel.innerHTML = '';
                const intro = document.createElement('div');
                intro.className = 'debug-line debug-info';
                intro.textContent = '‚ÑπÔ∏è Nouvelle tentative de connexion ‚Äî d√©tails √©tape par √©tape ci-dessous.';
                panel.appendChild(intro);
            }

            debugLog('üöÄ D√©marrage de la connexion...', 'info');
            
            const type = document.getElementById('connectionType').value;
            debugLog(`üì¶ Type de connexion: ${type === 'm3u' ? 'M3U/M3U8' : 'Xtream Codes'}`, 'info');
            
            let config = { type };
            
            if (type === 'm3u') {
                const rawUrl = document.getElementById('m3uUrl').value;
                debugLog('‚öôÔ∏è Validation des donn√©es M3U...', 'info');
                
                if (!rawUrl || !rawUrl.trim()) {
                    debugLog('‚ùå ERREUR: URL M3U vide', 'error');
                    showStatus('‚ùå Veuillez entrer une URL M3U', 'error');
                    return;
                }
                
                // Nettoyage intelligent de l'URL
                config.url = smartCleanUrl(rawUrl);
                
                if (!config.url.startsWith('http://') && !config.url.startsWith('https://')) {
                    debugLog('‚ùå ERREUR: URL invalide apr√®s nettoyage', 'error');
                    showStatus('‚ùå URL M3U invalide', 'error');
                    return;
                }
                
                if (!config.url.includes('.m3u') && !config.url.includes('.m3u8')) {
                    debugLog('‚ö†Ô∏è ATTENTION: L\'URL ne semble pas √™tre un fichier M3U/M3U8', 'warning');
                }
                
                debugLog(`‚úÖ URL M3U valide: ${config.url}`, 'success');
                
            } else {
                const rawUrl = document.getElementById('xtreamUrl').value;
                const rawUsername = document.getElementById('xtreamUsername').value;
                const rawPassword = document.getElementById('xtreamPassword').value;
                
                debugLog('‚öôÔ∏è Validation des donn√©es Xtream...', 'info');
                
                const missing = [];
                if (!rawUrl || !rawUrl.trim()) missing.push('URL serveur');
                if (!rawUsername || !rawUsername.trim()) missing.push('Nom d\'utilisateur');
                if (!rawPassword || !rawPassword.trim()) missing.push('Mot de passe');
                
                if (missing.length > 0) {
                    debugLog(`‚ùå ERREUR: Champs manquants: ${missing.join(', ')}`, 'error');
                    showStatus(`‚ùå Veuillez remplir: ${missing.join(', ')}`, 'error');
                    return;
                }
                
                // Nettoyage intelligent de l'URL
                config.url = smartCleanUrl(rawUrl);
                config.username = rawUsername.trim();
                config.password = rawPassword.trim();
                
                if (!config.url.startsWith('http://') && !config.url.startsWith('https://')) {
                    debugLog('‚ùå ERREUR: URL serveur invalide apr√®s nettoyage', 'error');
                    showStatus('‚ùå URL serveur invalide', 'error');
                    return;
                }
                
                if (config.url.endsWith('/')) {
                    debugLog('‚ö†Ô∏è URL se termine par /, sera nettoy√© automatiquement', 'warning');
                }
                
                debugLog(`‚úÖ URL serveur: ${config.url}`, 'success');
                debugLog(`‚úÖ Username: ${config.username}`, 'success');
                debugLog(`‚úÖ Password: ${'*'.repeat(config.password.length)} (${config.password.length} caract√®res)`, 'success');
                
                const specialChars = /[^a-zA-Z0-9_-]/;
                if (specialChars.test(config.username)) {
                    debugLog('‚ö†Ô∏è Username contient des caract√®res sp√©ciaux, sera encod√©', 'warning');
                }
                if (specialChars.test(config.password)) {
                    debugLog('‚ö†Ô∏è Password contient des caract√®res sp√©ciaux, sera encod√©', 'warning');
                }
            }
            
            try {
                localStorage.setItem('iptvConfig', JSON.stringify(config));
                debugLog('üíæ Configuration sauvegard√©e dans localStorage', 'success');
                showStatus('‚úÖ Configuration sauvegard√©e !', 'success');
            } catch (e) {
                debugLog(`‚ùå ERREUR localStorage: ${e.message}`, 'error');
                showStatus('‚ö†Ô∏è Configuration non sauvegard√©e (localStorage plein?)', 'warning');
            }
            
            debugLog('üöÄ Lancement du chargement des cha√Ænes...', 'info');
            loadChannels(config);
        }
        
        function loadSavedConfig() {
            const saved = localStorage.getItem('iptvConfig');
            if (saved) {
                const config = JSON.parse(saved);
                document.getElementById('connectionType').value = config.type;
                updateFormFields();
                
                if (config.type === 'm3u') {
                    document.getElementById('m3uUrl').value = config.url;
                } else {
                    document.getElementById('xtreamUrl').value = config.url;
                    document.getElementById('xtreamUsername').value = config.username;
                    document.getElementById('xtreamPassword').value = config.password;
                }
                
                // Auto-charger les cha√Ænes
                showStatus('üîÑ Chargement de la configuration sauvegard√©e...', 'success');
                setTimeout(() => loadChannels(config), 500);
            }
        }
        
        async function loadChannels(config) {
            try {
                if (config.type === 'm3u') {
                    await loadM3U(config.url);
                } else {
                    await loadXtream(config);
                }
            } catch (error) {
                showStatus('‚ùå Erreur: ' + error.message, 'error');
            }
        }
        
        async function loadM3U(url) {
            showStatus('üîÑ Chargement de la playlist M3U...', 'success');
            
            // Utiliser CORS proxy si n√©cessaire
            const proxyUrl = 'https://cors-anywhere.herokuapp.com/';
            const fetchUrl = url.startsWith('http://') ? proxyUrl + url : url;
            
            try {
                const response = await fetch(fetchUrl);
                const text = await response.text();
                
                channels = parseM3U(text);
                debugLog(`üì• Playlist M3U charg√©e via ${url.startsWith('http://') ? 'proxy CORS' : 'connexion directe'} ‚Äî ${channels.length} cha√Ænes d√©tect√©es`, channels.length ? 'success' : 'warning');
                displayChannels();
                showPlayer();
                if (!channels.length) {
                    showStatus('‚ö†Ô∏è Playlist charg√©e, mais aucune cha√Æne n\'a √©t√© d√©tect√©e. V√©rifiez le contenu du fichier M3U.', 'warning');
                } else {
                    showStatus(`‚úÖ ${channels.length} cha√Ænes charg√©es !`, 'success');
                }
            } catch (error) {
                // Si CORS proxy √©choue, essayer direct
                debugLog(`‚ö†Ô∏è √âchec du chargement M3U via proxy (${error.message}). Tentative directe...`, 'warning');
                try {
                    const response = await fetch(url);
                    const text = await response.text();
                    channels = parseM3U(text);
                    debugLog(`üì• Playlist M3U charg√©e en direct ‚Äî ${channels.length} cha√Ænes d√©tect√©es`, channels.length ? 'success' : 'warning');
                    displayChannels();
                    showPlayer();
                    if (!channels.length) {
                        showStatus('‚ö†Ô∏è Playlist charg√©e, mais aucune cha√Æne n\'a √©t√© d√©tect√©e. V√©rifiez le contenu du fichier M3U.', 'warning');
                    } else {
                        showStatus(`‚úÖ ${channels.length} cha√Ænes charg√©es !`, 'success');
                    }
                } catch (err) {
                    debugLog(`‚ùå Impossible de charger la playlist M3U: ${err.message}`, 'error');
                    showStatus('‚ùå Impossible de charger la playlist. V√©rifiez l\'URL ou le serveur.', 'error');
                }
            }
        }
        
        function parseM3U(text) {
            const lines = text.split('\n');
            const parsed = [];
            let current = {};
            
            for (let i = 0; i < lines.length; i++) {
                const line = lines[i].trim();
                
                if (line.startsWith('#EXTINF:')) {
                    const match = line.match(/,(.+)$/);
                    current.name = match ? match[1].trim() : 'Cha√Æne ' + (parsed.length + 1);
                } else if (line && !line.startsWith('#')) {
                    current.url = line;
                    if (current.name) {
                        parsed.push({...current});
                    }
                    current = {};
                }
            }
            
            return parsed;
        }

        function loadM3UExample() {
            const textarea = document.getElementById('m3uPaste');
            if (!textarea) {
                debugLog('‚ùå Zone "Coller playlist" introuvable pour l\'exemple', 'error');
                return;
            }

            const example = [
                '#EXTM3U',
                '#EXTINF:-1,Demo Channel 1',
                'https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8',
                '#EXTINF:-1,Demo Channel 2',
                'https://bitdash-a.akamaihd.net/content/sintel/hls/playlist.m3u8'
            ].join('\n');

            textarea.value = example;
            debugLog('üß™ Playlist M3U de d√©monstration inject√©e dans la zone de texte', 'info');
            loadM3UFromText();
        }

        function loadM3UFromText() {
            const textarea = document.getElementById('m3uPaste');
            if (!textarea) {
                debugLog('‚ùå Zone "Coller playlist" introuvable', 'error');
                return;
            }

            const raw = textarea.value || '';
            if (!raw.trim()) {
                showStatus('‚ùå Collez une playlist M3U dans la zone pr√©vue.', 'error');
                return;
            }

            debugLog('üìã Import de playlist M3U depuis texte coll√©', 'info');
            channels = parseM3U(raw);

            if (!channels.length) {
                showStatus('‚ö†Ô∏è Aucun canal d√©tect√© dans le texte M3U coll√©.', 'warning');
                return;
            }

            displayChannels();
            showPlayer();
            showStatus(`‚úÖ ${channels.length} cha√Ænes charg√©es depuis le texte coll√©.`, 'success');
        }

        function loadM3UFromFile() {
            const input = document.getElementById('m3uFile');
            if (!input || !input.files || !input.files.length) {
                showStatus('‚ùå S√©lectionnez un fichier M3U/M3U8 √† importer.', 'error');
                return;
            }

            const file = input.files[0];
            const reader = new FileReader();
            debugLog(`üìÅ Import de playlist M3U depuis fichier local: ${file.name}`, 'info');

            reader.onload = (e) => {
                const text = String(e.target.result || '');
                if (!text.trim()) {
                    showStatus('‚ö†Ô∏è Le fichier M3U est vide.', 'warning');
                    return;
                }

                channels = parseM3U(text);

                if (!channels.length) {
                    showStatus('‚ö†Ô∏è Aucun canal d√©tect√© dans le fichier M3U.', 'warning');
                    return;
                }

                displayChannels();
                showPlayer();
                showStatus(`‚úÖ ${channels.length} cha√Ænes charg√©es depuis le fichier local.`, 'success');
            };

            reader.onerror = () => {
                debugLog('‚ùå Erreur de lecture du fichier M3U', 'error');
                showStatus('‚ùå Impossible de lire le fichier M3U s√©lectionn√©.', 'error');
            };

            reader.readAsText(file);
        }
        
        // üíæ Syst√®me de cache intelligent
        function getCachedChannels(cacheKey) {
            try {
                const cached = localStorage.getItem(`iptv_cache_${cacheKey}`);
                if (!cached) return null;
                
                const data = JSON.parse(cached);
                const now = Date.now();
                
                if (now - data.timestamp > CACHE_DURATION_MS) {
                    debugLog('‚è∞ Cache expir√©, rechargement n√©cessaire', 'info');
                    localStorage.removeItem(`iptv_cache_${cacheKey}`);
                    return null;
                }
                
                debugLog(`‚úÖ Cache valide trouv√© (${data.channels.length} cha√Ænes, expire dans ${Math.round((CACHE_DURATION_MS - (now - data.timestamp)) / 60000)} min)`, 'success');
                return data.channels;
            } catch (e) {
                debugLog(`‚ö†Ô∏è Erreur lecture cache: ${e.message}`, 'warning');
                return null;
            }
        }
        
        function setCachedChannels(cacheKey, channelsList) {
            try {
                const data = {
                    channels: channelsList,
                    timestamp: Date.now()
                };
                localStorage.setItem(`iptv_cache_${cacheKey}`, JSON.stringify(data));
                debugLog(`üíæ ${channelsList.length} cha√Ænes mises en cache`, 'success');
            } catch (e) {
                debugLog(`‚ö†Ô∏è Erreur √©criture cache: ${e.message}`, 'warning');
            }
        }
        
        // üîÑ D√©tection automatique du meilleur proxy (health check)
        async function findBestProxy(proxies, testUrl) {
            debugLog('üè• Health check des proxies...', 'info');
            
            const proxyTests = proxies.map(async (proxy) => {
                const startTime = Date.now();
                try {
                    const testEndpoint = proxy.url + encodeURIComponent(testUrl);
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 3000);
                    
                    await fetch(testEndpoint, {
                        method: 'HEAD',
                        signal: controller.signal
                    });
                    
                    clearTimeout(timeoutId);
                    const responseTime = Date.now() - startTime;
                    debugLog(`‚úÖ ${proxy.name}: ${responseTime}ms`, 'success');
                    
                    return { proxy, responseTime, success: true };
                } catch (e) {
                    debugLog(`‚ùå ${proxy.name}: √©chec`, 'warning');
                    return { proxy, responseTime: 9999, success: false };
                }
            });
            
            const results = await Promise.all(proxyTests);
            const successfulProxies = results.filter(r => r.success).sort((a, b) => a.responseTime - b.responseTime);
            
            if (successfulProxies.length > 0) {
                const best = successfulProxies[0];
                debugLog(`üèÜ Meilleur proxy: ${best.proxy.name} (${best.responseTime}ms)`, 'success');
                return best.proxy;
            }
            
            return null;
        }
        
        // üîÅ Retry automatique intelligent
        async function fetchWithRetry(url, options, maxRetries = 2) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    debugLog(`üéØ Tentative ${attempt}/${maxRetries}...`, 'info');
                    const response = await fetch(url, options);
                    return response;
                } catch (error) {
                    if (attempt === maxRetries) {
                        throw error;
                    }
                    const waitTime = attempt * 1000;
                    debugLog(`‚è≥ √âchec, nouvelle tentative dans ${waitTime}ms...`, 'warning');
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                }
            }
        }
        
        // üé¨ S√©lection intelligente du proxy de streaming
        function selectStreamProxy() {
            // Initialiser le Cloudflare Worker si configur√©
            if (CLOUDFLARE_PROXY && STREAM_PROXIES[0].url === null) {
                STREAM_PROXIES[0].url = CLOUDFLARE_PROXY + '?url=';
                debugLog('‚ö° Cloudflare Worker configur√© pour les streams', 'success');
            }
            
            // Si on a d√©j√† un proxy qui fonctionne, le r√©utiliser
            if (currentStreamProxy) {
                debugLog(`üîÑ R√©utilisation du proxy: ${currentStreamProxy.name}`, 'info');
                return currentStreamProxy;
            }
            
            // Sinon, utiliser le proxy qui a fonctionn√© pour l'API
            if (usedProxyForApi) {
                const apiProxyMatch = STREAM_PROXIES.find(p => p.url === usedProxyForApi);
                if (apiProxyMatch) {
                    currentStreamProxy = apiProxyMatch;
                    debugLog(`üîÑ Utilisation du proxy de l'API: ${apiProxyMatch.name}`, 'success');
                    return apiProxyMatch;
                }
            }
            
            // Sinon, prendre le premier proxy disponible par priorit√©
            const availableProxies = STREAM_PROXIES.filter(p => p.url !== null).sort((a, b) => a.priority - b.priority);
            if (availableProxies.length > 0) {
                currentStreamProxy = availableProxies[0];
                debugLog(`üéØ S√©lection proxy par d√©faut: ${currentStreamProxy.name}`, 'info');
                return currentStreamProxy;
            }
            
            debugLog('‚ùå Aucun proxy de streaming disponible', 'error');
            return null;
        }
        
        // üîÑ Passer au proxy suivant en cas d'√©chec
        function switchToNextStreamProxy() {
            if (!currentStreamProxy) return selectStreamProxy();
            
            // Marquer l'√©chec du proxy actuel
            const proxyUrl = currentStreamProxy.url;
            streamProxyRetries[proxyUrl] = (streamProxyRetries[proxyUrl] || 0) + 1;
            
            debugLog(`‚ö†Ô∏è √âchec du proxy ${currentStreamProxy.name} (${streamProxyRetries[proxyUrl]} √©checs)`, 'warning');
            
            // Trouver le proxy suivant
            const availableProxies = STREAM_PROXIES.filter(p => 
                p.url !== null && 
                p.url !== currentStreamProxy.url &&
                (streamProxyRetries[p.url] || 0) < 3 // Max 3 √©checs par proxy
            ).sort((a, b) => a.priority - b.priority);
            
            if (availableProxies.length > 0) {
                currentStreamProxy = availableProxies[0];
                debugLog(`üîÑ Basculement vers: ${currentStreamProxy.name}`, 'info');
                return currentStreamProxy;
            }
            
            debugLog('‚ùå Plus de proxy de streaming disponible', 'error');
            // R√©initialiser les compteurs d'√©checs pour recommencer
            streamProxyRetries = {};
            currentStreamProxy = null;
            return selectStreamProxy();
        }
        
        // üîÅ Retry lecture avec proxy suivant
        function retryPlayWithNextProxy(channel) {
            if (!channel._originalUrl) {
                debugLog('‚ùå Impossible de retry: URL originale manquante', 'error');
                showStatus('‚ùå Impossible de relancer la lecture', 'error');
                return;
            }
            
            const nextProxy = switchToNextStreamProxy();
            if (!nextProxy || !nextProxy.url) {
                debugLog('‚ùå Plus de proxy disponible pour retry', 'error');
                showStatus('‚ùå Tous les proxies ont √©chou√©. Essaie une autre cha√Æne ou r√©essaie plus tard.', 'error');
                return;
            }
            
            debugLog(`üîÑ Retry avec ${nextProxy.name}...`, 'info');
            showStatus(`üîÑ Nouvelle tentative via ${nextProxy.name}...`, 'warning');
            
            // Reconstruire le channel avec le nouveau proxy
            const retryChannel = {
                ...channel,
                url: channel._originalUrl,
                _retryAttempt: (channel._retryAttempt || 0) + 1
            };
            
            // Limiter √† 3 retries max
            if (retryChannel._retryAttempt > 3) {
                debugLog('‚ùå Trop de tentatives (3 max)', 'error');
                showStatus('‚ùå La cha√Æne ne fonctionne pas apr√®s 3 tentatives. Essaie une autre cha√Æne.', 'error');
                return;
            }
            
            // Relancer la lecture
            setTimeout(() => {
                playChannel(retryChannel);
            }, 1000);
        }
        
        async function loadXtream(config) {
            debugLog('üíâ loadXtream() appel√©', 'info');
            showStatus('üîÑ Connexion au serveur Xtream Codes...', 'success');
            
            let serverUrl = config.url.trim();
            debugLog(`üßπ URL originale: ${serverUrl}`, 'info');
            
            if (serverUrl.endsWith('/')) {
                serverUrl = serverUrl.slice(0, -1);
                debugLog(`üßπ URL nettoy√©e (/ retir√©): ${serverUrl}`, 'info');
            }
            
            const apiUrl = `${serverUrl}/player_api.php?username=${encodeURIComponent(config.username)}&password=${encodeURIComponent(config.password)}&action=get_live_streams`;
            const safeApiUrl = apiUrl.replace(config.password, '***').replace(encodeURIComponent(config.password), '***');
            
            debugLog(`üîó URL API construite: ${safeApiUrl}`, 'info');
            
            // üíæ V√©rifier le cache d'abord
            const cacheKey = `${config.username}@${serverUrl}`;
            const cachedChannels = getCachedChannels(cacheKey);
            
            if (cachedChannels && cachedChannels.length > 0) {
                debugLog(`‚úÖ Utilisation du cache (${cachedChannels.length} cha√Ænes)`, 'success');
                channels = cachedChannels;
                currentPage = 1;
                totalPages = Math.ceil(channels.length / MAX_CHANNELS_PER_PAGE);
                displayChannels();
                showPlayer();
                showStatus(`‚úÖ ${channels.length} cha√Ænes charg√©es depuis le cache !`, 'success');
                debugLog(`üí° Le cache sera actualis√© automatiquement dans ${Math.round((CACHE_DURATION_MS) / 60000)} minutes ou tu peux forcer le rechargement`, 'info');
                return;
            }
            
            const startTime = Date.now();
            
            try {
                debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
                debugLog('üîÑ √âTAPE 1/3: Tentative de connexion DIRECTE (sans proxy)', 'info');
                debugLog('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'info');
                showStatus('üîÑ √âtape 1/3: Connexion DIRECTE au serveur...', 'success');
                
                let response;
                let data;
                let usedProxy = false;
                
                try {
                    debugLog(`üéØ Envoi requ√™te GET DIRECTE vers: ${apiUrl.substring(0, 60)}...`, 'info');
                    debugLog(`‚è±Ô∏è Timeout: 5 secondes`, 'info');
                    
                    // Promesse avec timeout plus court pour √©viter les freezes
                    const fetchWithTimeout = (url, options, timeout = 5000) => {
                        return Promise.race([
                            fetch(url, options),
                            new Promise((_, reject) => 
                                setTimeout(() => reject(new Error('Timeout d√©pass√© (5s)')), timeout)
                            )
                        ]);
                    };
                    
                    response = await fetchWithTimeout(apiUrl, {
                        method: 'GET',
                        headers: { 'Accept': 'application/json' },
                        mode: 'cors' // Explicite pour la d√©tection CORS
                    });
                    
                    const elapsed = Date.now() - startTime;
                    debugLog(`‚úÖ R√©ponse DIRECTE re√ßue en ${elapsed}ms`, 'success');
                    debugLog(`üìä Status HTTP: ${response.status} ${response.statusText}`, response.ok ? 'success' : 'error');
                    debugLog(`üì¶ Content-Type: ${response.headers.get('content-type')}`, 'info');
                    
                    if (!response.ok) {
                        debugLog(`‚ùå Erreur HTTP ${response.status}`, 'error');
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const text = await response.text();
                    debugLog(`üìù Longueur r√©ponse: ${text.length} caract√®res`, 'info');
                    debugLog(`üì• Aper√ßu r√©ponse: ${text.substring(0, 200)}${text.length > 200 ? '...' : ''}`, 'info');
                    
                    try {
                        data = JSON.parse(text);
                        debugLog(`‚úÖ JSON pars√© avec succ√®s (connexion DIRECTE r√©ussie !)`, 'success');
                        debugLog(`üéâ Aucun proxy n√©cessaire, connexion directe fonctionnelle`, 'success');
                    } catch (e) {
                        debugLog(`‚ùå ERREUR parsing JSON: ${e.message}`, 'error');
                        throw new Error('La r√©ponse n\'est pas du JSON valide: ' + text.substring(0, 100));
                    }
                    
                } catch (directError) {
                    const elapsed = Date.now() - startTime;
                    debugLog(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'warning');
                    debugLog(`‚ùå Connexion DIRECTE √©chou√©e apr√®s ${elapsed}ms`, 'warning');
                    debugLog(`üìã Raison: ${directError.message}`, 'warning');
                    
                    // Diagnostic d√©taill√© de l'erreur
                    if (directError.message.includes('Failed to fetch')) {
                        debugLog(`üîç Diagnostic: Erreur CORS - Le serveur bloque les requ√™tes depuis le navigateur`, 'warning');
                        debugLog(`üí° Le serveur IPTV n'autorise pas les connexions web directes`, 'info');
                    } else if (directError.message.includes('Timeout')) {
                        debugLog(`üîç Diagnostic: Le serveur met trop de temps √† r√©pondre`, 'warning');
                    } else if (directError.message.includes('network')) {
                        debugLog(`üîç Diagnostic: Probl√®me de connexion r√©seau`, 'warning');
                    }
                    
                    debugLog(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'warning');
                    debugLog(`üîÑ √âTAPE 2/3: Tentative avec proxies CORS...`, 'info');
                    showStatus('üîÑ √âtape 2/3: Utilisation de proxies CORS...', 'success');
                    
                    // Construction de la liste des proxies (Cloudflare Worker en priorit√© si configur√©)
                    const proxies = [];
                    if (CLOUDFLARE_PROXY) {
                        proxies.push({ 
                            name: 'Cloudflare Worker (priv√©)', 
                            url: CLOUDFLARE_PROXY + '?url=',
                            isCloudflare: true
                        });
                        debugLog(`‚ö° Proxy Cloudflare Worker configur√© et sera test√© en priorit√©`, 'info');
                    }
                    // Proxies publics en fallback (plus de choix pour plus de fiabilit√©)
                    proxies.push(
                        { name: 'cors-anywhere.herokuapp.com', url: 'https://cors-anywhere.herokuapp.com/' },
                        { name: 'corsproxy.io', url: 'https://corsproxy.io/?' },
                        { name: 'api.codetabs.com', url: 'https://api.codetabs.com/v1/proxy?quest=' },
                        { name: 'api.allorigins.win', url: 'https://api.allorigins.win/raw?url=' },
                        { name: 'cors.eu.org', url: 'https://cors.eu.org/' }
                    );
                    const proxyTimeoutMs = 5000;
                    
                    let proxySuccess = false;
                    let lastProxyError = null;
                    
                    for (const proxy of proxies) {
                        try {
                            debugLog(`üåê Test proxy: ${proxy.name}...`, 'info');
                            const proxiedUrl = proxy.url + encodeURIComponent(apiUrl);
                            
                            const proxyFetchWithTimeout = (url, options, timeout = proxyTimeoutMs) => {
                                return Promise.race([
                                    fetch(url, options),
                                    new Promise((_, reject) => 
                                        setTimeout(() => reject(new Error(`Timeout proxy (${timeout}ms)`)), timeout)
                                    )
                                ]);
                            };
                            
                            response = await proxyFetchWithTimeout(proxiedUrl, {
                                method: 'GET',
                                headers: { 'Accept': 'application/json' }
                            }, proxyTimeoutMs);
                            const elapsed = Date.now() - startTime;
                            debugLog(`‚è±Ô∏è R√©ponse ${proxy.name} re√ßue en ${elapsed}ms`, 'info');
                            
                            const text = await response.text();
                            debugLog(`üìù Longueur r√©ponse ${proxy.name}: ${text.length} caract√®res`, 'info');
                            
                            // V√©rifier si c'est une erreur du proxy lui-m√™me
                            if (text.includes('"error"') && text.length < 200) {
                                debugLog(`‚ö†Ô∏è ${proxy.name} retourne une erreur: ${text.substring(0, 100)}`, 'warning');
                                lastProxyError = `${proxy.name}: erreur interne`;
                                continue; // Essayer le proxy suivant
                            }
                            
                            data = JSON.parse(text);
                            
                            // V√©rifier si la r√©ponse contient une erreur
                            if (data && data.error && !data.streams && !Array.isArray(data)) {
                                debugLog(`‚ö†Ô∏è ${proxy.name} retourne une erreur proxy: ${JSON.stringify(data).substring(0, 100)}`, 'warning');
                                lastProxyError = `${proxy.name}: ${data.error}`;
                                continue; // Essayer le proxy suivant
                            }
                            
                            usedProxy = true;
                            proxySuccess = true;
                            usedProxyForApi = proxy.url; // M√©moriser le proxy qui a fonctionn√©
                            debugLog(`‚úÖ Connexion via ${proxy.name} r√©ussie`, 'success');
                            debugLog(`üíæ Proxy m√©moris√© pour les streams: ${proxy.name}`, 'info');
                            break; // Succ√®s, sortir de la boucle
                            
                        } catch (proxyError) {
                            debugLog(`‚ùå ${proxy.name} √©chou√©: ${proxyError.message}`, 'warning');
                            lastProxyError = `${proxy.name}: ${proxyError.message}`;
                            // Continuer avec le proxy suivant
                        }
                    }
                    
                    if (!proxySuccess) {
                        debugLog(`‚ùå Tous les proxies CORS ont √©chou√©`, 'error');
                        debugLog(`üí° SOLUTION: Le serveur IPTV bloque probablement les proxies publics`, 'info');
                        debugLog(`üí° OPTIONS:`, 'info');
                        debugLog(`   1Ô∏è‚É£ Utilise le player directement depuis http:// (pas https://)`, 'info');
                        debugLog(`   2Ô∏è‚É£ Installe une extension CORS dans ton navigateur`, 'info');
                        debugLog(`   3Ô∏è‚É£ Demande √† ton fournisseur IPTV s'il a une URL avec CORS activ√©`, 'info');
                        throw new Error(`Tous les proxies ont √©chou√©. Dernier: ${lastProxyError}. Le serveur IPTV n√©cessite probablement un acc√®s direct (pas via proxy). Essaie d'ouvrir le player en HTTP au lieu de HTTPS, ou demande √† ton fournisseur IPTV une URL compatible avec les navigateurs web.`);
                    }
                }
                
                debugLog(`üîÑ √âTAPE 3/3: Analyse et traitement des donn√©es...`, 'info');
                showStatus('üîÑ √âtape 3/3: Traitement des cha√Ænes...', 'success');
                
                debugLog(`üîç Type de donn√©es re√ßues: ${Array.isArray(data) ? 'Array' : typeof data}`, 'info');
                
                let streamsList = [];
                
                if (Array.isArray(data)) {
                    streamsList = data;
                    debugLog(`‚úÖ Format d√©tect√©: Array direct de ${streamsList.length} √©l√©ments`, 'success');
                } else if (data && typeof data === 'object') {
                    debugLog(`üîç Cl√©s de l'objet: ${Object.keys(data).join(', ')}`, 'info');
                    
                    if (data.streams && Array.isArray(data.streams)) {
                        streamsList = data.streams;
                        debugLog(`‚úÖ Format d√©tect√©: data.streams avec ${streamsList.length} cha√Ænes`, 'success');
                    } else if (data.data && Array.isArray(data.data)) {
                        streamsList = data.data;
                        debugLog(`‚úÖ Format d√©tect√©: data.data avec ${streamsList.length} cha√Ænes`, 'success');
                    } else {
                        if (data.user_info) {
                            debugLog(`üë§ Info utilisateur pr√©sente:`, 'info');
                            debugLog(`   - Username: ${data.user_info.username || 'N/A'}`, 'info');
                            debugLog(`   - Status: ${data.user_info.status || 'N/A'}`, 'info');
                            debugLog(`   - Exp date: ${data.user_info.exp_date || 'N/A'}`, 'info');
                            debugLog(`‚ùå Aucune cha√Æne disponible pour cet abonnement`, 'error');
                            throw new Error('Aucune cha√Æne disponible pour cet abonnement');
                        }
                        debugLog(`‚ùå Format de r√©ponse non reconnu`, 'error');
                        throw new Error('Format de r√©ponse inattendu: ' + JSON.stringify(data).substring(0, 100));
                    }
                } else {
                    debugLog(`‚ùå Type de donn√©es invalide: ${typeof data}`, 'error');
                    throw new Error('Donn√©es invalides re√ßues du serveur');
                }
                
                if (streamsList.length === 0) {
                    debugLog(`‚ùå Liste de cha√Ænes vide`, 'error');
                    throw new Error('Aucune cha√Æne trouv√©e sur ce serveur');
                }
                
                debugLog(`‚úÖ ${streamsList.length} cha√Ænes trouv√©es dans la r√©ponse`, 'success');
                
                if (streamsList.length > 0) {
                    const first = streamsList[0];
                    debugLog(`üì¶ Exemple 1√®re cha√Æne: ${first.name || first.stream_display_name || 'N/A'}`, 'info');
                }
                
                debugLog(`üõ†Ô∏è Mapping de ${streamsList.length} cha√Ænes...`, 'info');
                
                // Initialiser la pagination
                currentPage = 1;
                totalPages = Math.ceil(streamsList.length / MAX_CHANNELS_PER_PAGE);
                
                if (streamsList.length > MAX_CHANNELS_PER_PAGE) {
                    debugLog(`üìä Pagination activ√©e: ${totalPages} pages de ${MAX_CHANNELS_PER_PAGE} cha√Ænes max`, 'info');
                }
                
                channels = streamsList.map((ch) => {
                    const streamId = ch.stream_id || ch.id || ch.num;
                    const channelName = ch.name || ch.stream_display_name || ch.title || `Cha√Æne ${streamId}`;
                    const categoryName = ch.category_name || ch.category || '';
                    
                    return {
                        name: channelName,
                        url: `${serverUrl}/live/${config.username}/${config.password}/${streamId}.m3u8`,
                        category: categoryName,
                        streamId: streamId
                    };
                });
                
                const totalTime = Date.now() - startTime;
                debugLog(`‚è±Ô∏è Temps total de traitement: ${totalTime}ms`, 'success');
                debugLog(`‚úÖ ${channels.length} cha√Ænes mapp√©es avec succ√®s`, 'success');
                
                // üíæ Sauvegarder dans le cache
                setCachedChannels(cacheKey, channels);
                
                displayChannels();
                showPlayer();
                
                const successMsg = `‚úÖ ${channels.length} cha√Ænes Xtream charg√©es ${usedProxy ? '(via proxy)' : '(direct)'} !`;
                showStatus(successMsg, 'success');
                debugLog(successMsg, 'success');
                
            } catch (error) {
                const totalTime = Date.now() - startTime;
                debugLog(`‚ùå ERREUR FATALE apr√®s ${totalTime}ms`, 'error');
                debugLog(`‚ùå Type d'erreur: ${error.name}`, 'error');
                debugLog(`‚ùå Message: ${error.message}`, 'error');
                
                if (error.stack) {
                    debugLog(`üîç Stack trace:`, 'error');
                    error.stack.split('\n').slice(0, 3).forEach(line => {
                        debugLog(`   ${line.trim()}`, 'error');
                    });
                }
                
                let errorMessage = '‚ùå Erreur Xtream: ';
                let userTip = '';
                
                if (error.message.includes('Failed to fetch')) {
                    errorMessage += 'Impossible de contacter le serveur.';
                    userTip = 'üí° V√©rifiez: 1) L\'URL du serveur, 2) Votre connexion Internet, 3) Le serveur est en ligne';
                    debugLog(userTip, 'warning');
                } else if (error.message.includes('HTTP 401') || error.message.includes('Unauthorized')) {
                    errorMessage += 'Identifiants incorrects.';
                    userTip = 'üí° V√©rifiez: 1) Nom d\'utilisateur correct, 2) Mot de passe correct, 3) Pas d\'espaces en trop';
                    debugLog(userTip, 'warning');
                } else if (error.message.includes('HTTP 403') || error.message.includes('Forbidden')) {
                    errorMessage += 'Acc√®s refus√©.';
                    userTip = 'üí° V√©rifiez: 1) Abonnement valide, 2) Pas expir√©, 3) Connexions simultan√©es limit√©es';
                    debugLog(userTip, 'warning');
                } else if (error.message.includes('HTTP 404')) {
                    errorMessage += 'Serveur introuvable.';
                    userTip = 'üí° V√©rifiez: 1) URL compl√®te avec port, 2) Pas de faute de frappe, 3) Serveur utilise bien Xtream API';
                    debugLog(userTip, 'warning');
                } else if (error.message.includes('JSON')) {
                    errorMessage += 'R√©ponse invalide du serveur.';
                    userTip = 'üí° Le serveur ne semble pas √™tre un serveur Xtream Codes valide';
                    debugLog(userTip, 'warning');
                } else if (error.message.includes('Aucune cha√Æne')) {
                    errorMessage += error.message;
                    userTip = 'üí° Votre abonnement ne contient aucune cha√Æne live';
                    debugLog(userTip, 'warning');
                } else {
                    errorMessage += error.message;
                }
                
                showStatus(errorMessage, 'error');
                debugLog(`üíî √âchec total du chargement Xtream`, 'error');
            }
        }
        
        function displayChannels() {
            const container = document.getElementById('channelsList');
            if (!container) {
                debugLog('‚ùå Conteneur "channelsList" introuvable, impossible d\'afficher les cha√Ænes', 'error');
                return;
            }

            container.innerHTML = '';

            if (!Array.isArray(channels) || channels.length === 0) {
                debugLog('‚ö†Ô∏è Aucune cha√Æne √† afficher (liste vide)', 'warning');
                container.innerHTML = '<p style="text-align: center; color: #94a3b8; padding: 24px;">Aucune cha√Æne disponible pour cette playlist ou ce serveur.</p>';
                // Masquer pagination
                document.getElementById('paginationTop').style.display = 'none';
                document.getElementById('paginationBottom').style.display = 'none';
                return;
            }

            // Calculer pagination
            const totalChannels = channels.length;
            totalPages = Math.ceil(totalChannels / MAX_CHANNELS_PER_PAGE);
            
            // Borner la page actuelle
            if (currentPage < 1) currentPage = 1;
            if (currentPage > totalPages) currentPage = totalPages;
            
            // Calculer les indices de d√©but et fin
            const startIndex = (currentPage - 1) * MAX_CHANNELS_PER_PAGE;
            const endIndex = Math.min(startIndex + MAX_CHANNELS_PER_PAGE, totalChannels);
            const channelsToDisplay = channels.slice(startIndex, endIndex);
            
            debugLog(`üì∫ Affichage page ${currentPage}/${totalPages}: cha√Ænes ${startIndex + 1}-${endIndex} sur ${totalChannels}`, 'info');
            
            // Afficher/masquer contr√¥les pagination
            if (totalPages > 1) {
                document.getElementById('paginationTop').style.display = 'block';
                document.getElementById('paginationBottom').style.display = 'block';
                updatePaginationControls();
            } else {
                document.getElementById('paginationTop').style.display = 'none';
                document.getElementById('paginationBottom').style.display = 'none';
            }
            
            // Utiliser DocumentFragment pour optimiser l'ajout au DOM
            const fragment = document.createDocumentFragment();
            
            channelsToDisplay.forEach((channel, index) => {
                const card = document.createElement('div');
                const compat = evaluateChannelCompatibility(channel);

                let cardClasses = 'channel-card';
                if (!compat.supported) {
                    cardClasses += ' disabled';
                }
                card.className = cardClasses;

                // Normaliser l'objet pour l'historique/favoris
                const item = {
                    name: channel.name,
                    url: channel.url,
                    category: channel.category || 'Live'
                };

                const isFav = favorites.some(f => f.url === item.url);
                const safeItem = JSON.stringify(item).replace(/"/g, '&quot;');

                let compatClass = 'channel-compat';
                let compatText = '';

                if (!compat.supported) {
                    compatClass += ' channel-compat-bad';
                    compatText = `‚ö†Ô∏è Non compatible sur ce navigateur: ${compat.reason}`;
                } else if (compat.warning) {
                    compatClass += ' channel-compat-warning';
                    compatText = `‚ö†Ô∏è Compatibilit√© non garantie (${compat.reason})`;
                } else {
                    compatClass += ' channel-compat-ok';
                    compatText = `‚úÖ Compatible ${compat.format !== 'inconnu' ? compat.format : ''}`.trim();
                }

                card.innerHTML = `
                    <button class="favorite-btn ${isFav ? 'active' : ''}" onclick="event.stopPropagation(); toggleFavorite(${safeItem})">
                        ${isFav ? '‚ù§Ô∏è' : 'ü§ç'}
                    </button>
                    <h3>üì∫ ${channel.name}</h3>
                    ${channel.category ? `<p>${channel.category}</p>` : ''}
                    <p class="${compatClass}">${compatText}</p>
                `;

                card.onclick = () => {
                    playChannel(channel);
                    addToHistory(item);
                };
                
                fragment.appendChild(card);
            });
            
            // Ajouter tous les √©l√©ments d'un coup au DOM
            container.appendChild(fragment);
            debugLog(`‚úÖ ${channelsToDisplay.length} cha√Ænes affich√©es (page ${currentPage}/${totalPages})`, 'success');
        }
        
        // üìÑ Fonctions de pagination
        function changePage(newPage) {
            if (newPage < 1 || newPage > totalPages) return;
            currentPage = newPage;
            displayChannels();
            // Scroller en haut de la liste
            document.getElementById('channelsList').scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
        
        function updatePaginationControls() {
            const totalChannels = channels.length;
            
            // Mettre √† jour les √©l√©ments en haut
            document.getElementById('currentPageTop').textContent = currentPage;
            document.getElementById('totalPagesTop').textContent = totalPages;
            document.getElementById('channelsCountTop').textContent = totalChannels;
            
            // Mettre √† jour les √©l√©ments en bas
            document.getElementById('currentPageBottom').textContent = currentPage;
            document.getElementById('totalPagesBottom').textContent = totalPages;
            document.getElementById('channelsCountBottom').textContent = totalChannels;
        }
        
        // üîç Recherche intelligente avec filtrage global
        let allChannelsBackup = [];  // Backup pour restaurer apr√®s recherche
        let isSearchActive = false;
        
        function filterContent() {
            const searchBox = document.getElementById('searchBox');
            if (!searchBox) return;
            
            const search = searchBox.value.toLowerCase().trim();
            
            if (!search) {
                // Restaurer toutes les cha√Ænes si recherche vide
                if (isSearchActive && allChannelsBackup.length > 0) {
                    channels = allChannelsBackup;
                    allChannelsBackup = [];
                    isSearchActive = false;
                    currentPage = 1;
                    displayChannels();
                    debugLog('üîç Recherche effac√©e, affichage de toutes les cha√Ænes', 'info');
                }
                return;
            }
            
            // Sauvegarder toutes les cha√Ænes la premi√®re fois
            if (!isSearchActive) {
                allChannelsBackup = [...channels];
                isSearchActive = true;
            }
            
            // Filtrer sur toutes les cha√Ænes
            const filtered = allChannelsBackup.filter(channel => {
                const name = (channel.name || '').toLowerCase();
                const category = (channel.category || '').toLowerCase();
                return name.includes(search) || category.includes(search);
            });
            
            channels = filtered;
            currentPage = 1;
            displayChannels();
            
            debugLog(`üîç Recherche: "${search}" ‚Üí ${filtered.length} r√©sultat(s)`, 'info');
            
            if (filtered.length === 0) {
                showStatus(`‚ùå Aucun r√©sultat pour "${search}"`, 'warning');
            } else {
                showStatus(`‚úÖ ${filtered.length} r√©sultat(s) pour "${search}"`, 'success');
            }
        }
        
        // Charger les films depuis Xtream
        async function loadMovies() {
            if (!channels.length) {
                showStatus('‚ö†Ô∏è Chargez d\'abord les cha√Ænes', 'warning');
                return;
            }
            
            debugLog('üé¨ Chargement des films...', 'info');
            showStatus('üîÑ Chargement des films...', 'success');
            
            const config = JSON.parse(localStorage.getItem('iptvConfig'));
            if (!config || config.type !== 'xtream') {
                showStatus('‚ö†Ô∏è Les films n√©cessitent Xtream Codes', 'warning');
                return;
            }
            
            try {
                let serverUrl = config.url.trim();
                if (serverUrl.endsWith('/')) serverUrl = serverUrl.slice(0, -1);
                
                const apiUrl = `${serverUrl}/player_api.php?username=${encodeURIComponent(config.username)}&password=${encodeURIComponent(config.password)}&action=get_vod_streams`;
                
                const response = await fetch(apiUrl);
                const data = await response.json();
                
                movies = Array.isArray(data) ? data.map((m, i) => ({
                    name: m.name || m.title || `Film ${i+1}`,
                    url: `${serverUrl}/movie/${config.username}/${config.password}/${m.stream_id}.${m.container_extension || 'mp4'}`,
                    category: m.category_name || 'Films',
                    poster: m.stream_icon || m.cover_big || null,
                    streamId: m.stream_id
                })) : [];
                
                debugLog(`‚úÖ ${movies.length} films charg√©s`, 'success');
                displayMovies();
            } catch (error) {
                debugLog(`‚ùå Erreur chargement films: ${error.message}`, 'error');
                showStatus('‚ùå Impossible de charger les films', 'error');
            }
        }
        
        function displayMovies() {
            const container = document.getElementById('moviesList');
            container.innerHTML = '';
            
            if (movies.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #94a3b8; padding: 40px;">Aucun film disponible</p>';
                return;
            }
            
            movies.forEach(movie => {
                const card = createMediaCard(movie);
                container.appendChild(card);
            });
        }
        
        // Charger les s√©ries depuis Xtream
        async function loadSeries() {
            if (!channels.length) {
                showStatus('‚ö†Ô∏è Chargez d\'abord les cha√Ænes', 'warning');
                return;
            }
            
            debugLog('üì∫ Chargement des s√©ries...', 'info');
            showStatus('üîÑ Chargement des s√©ries...', 'success');
            
            const config = JSON.parse(localStorage.getItem('iptvConfig'));
            if (!config || config.type !== 'xtream') {
                showStatus('‚ö†Ô∏è Les s√©ries n√©cessitent Xtream Codes', 'warning');
                return;
            }
            
            try {
                let serverUrl = config.url.trim();
                if (serverUrl.endsWith('/')) serverUrl = serverUrl.slice(0, -1);
                
                const apiUrl = `${serverUrl}/player_api.php?username=${encodeURIComponent(config.username)}&password=${encodeURIComponent(config.password)}&action=get_series`;
                
                const response = await fetch(apiUrl);
                const data = await response.json();
                
                series = Array.isArray(data) ? data.map((s, i) => ({
                    name: s.name || s.title || `S√©rie ${i+1}`,
                    url: `${serverUrl}/series/${config.username}/${config.password}/${s.series_id}.m3u8`,
                    category: s.category_name || 'S√©ries',
                    poster: s.cover || s.cover_big || null,
                    seriesId: s.series_id
                })) : [];
                
                debugLog(`‚úÖ ${series.length} s√©ries charg√©es`, 'success');
                displaySeries();
            } catch (error) {
                debugLog(`‚ùå Erreur chargement s√©ries: ${error.message}`, 'error');
                showStatus('‚ùå Impossible de charger les s√©ries', 'error');
            }
        }
        
        function displaySeries() {
            const container = document.getElementById('seriesList');
            container.innerHTML = '';
            
            if (series.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #94a3b8; padding: 40px;">Aucune s√©rie disponible</p>';
                return;
            }
            
            series.forEach(serie => {
                const card = createMediaCard(serie);
                container.appendChild(card);
            });
        }
        
        // Charger l'EPG (Electronic Program Guide)
        async function loadEPG() {
            debugLog('üìã Chargement de l\'EPG...', 'info');
            showStatus('üîÑ Chargement du guide des programmes...', 'success');
            
            const config = JSON.parse(localStorage.getItem('iptvConfig'));
            
            try {
                // G√©n√©rer un EPG fictif avec horaires r√©alistes
                const now = new Date();
                epgData = channels.slice(0, 10).flatMap((channel, index) => {
                    const programs = [];
                    let startTime = new Date(now);
                    startTime.setHours(6, 0, 0, 0);
                    
                    const programTemplates = [
                        { title: 'Journal du matin', duration: 30 },
                        { title: 'M√©t√©o', duration: 15 },
                        { title: 'Magazine', duration: 60 },
                        { title: 'Film', duration: 120 },
                        { title: 'S√©rie', duration: 45 },
                        { title: 'Documentaire', duration: 60 },
                        { title: 'Journal du soir', duration: 30 },
                        { title: 'Divertissement', duration: 90 }
                    ];
                    
                    for (let i = 0; i < 8; i++) {
                        const template = programTemplates[i];
                        const endTime = new Date(startTime.getTime() + template.duration * 60000);
                        const isCurrent = now >= startTime && now < endTime;
                        
                        programs.push({
                            channel: channel.name,
                            title: template.title,
                            start: startTime.toISOString(),
                            end: endTime.toISOString(),
                            description: `${template.title} sur ${channel.name}`,
                            isCurrent: isCurrent
                        });
                        
                        startTime = new Date(endTime);
                    }
                    
                    return programs;
                });
                
                debugLog(`‚úÖ EPG g√©n√©r√©: ${epgData.length} programmes`, 'success');
                displayEPG();
            } catch (error) {
                debugLog(`‚ùå Erreur chargement EPG: ${error.message}`, 'error');
                showStatus('‚ùå Impossible de charger l\'EPG', 'error');
            }
        }
        
        function displayEPG() {
            const container = document.getElementById('epgTimeline');
            container.innerHTML = '';
            
            if (epgData.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #94a3b8; padding: 40px;">Aucun programme disponible</p>';
                return;
            }
            
            // Grouper par cha√Æne
            const byChannel = {};
            epgData.forEach(prog => {
                if (!byChannel[prog.channel]) byChannel[prog.channel] = [];
                byChannel[prog.channel].push(prog);
            });
            
            // Afficher les programmes actuels et √† venir
            Object.entries(byChannel).forEach(([channel, programs]) => {
                const now = new Date();
                const upcoming = programs.filter(p => new Date(p.start) >= now).slice(0, 3);
                
                upcoming.forEach(prog => {
                    const card = document.createElement('div');
                    card.className = `epg-program ${prog.isCurrent ? 'current' : ''}`;
                    
                    const start = new Date(prog.start);
                    const end = new Date(prog.end);
                    
                    card.innerHTML = `
                        <div class="epg-time">
                            ${start.toLocaleTimeString('fr-FR', {hour: '2-digit', minute: '2-digit'})} - 
                            ${end.toLocaleTimeString('fr-FR', {hour: '2-digit', minute: '2-digit'})}
                            ${prog.isCurrent ? '<span style="color: #22c55e; margin-left: 8px;">‚óè EN DIRECT</span>' : ''}
                        </div>
                        <div class="epg-title">${prog.title}</div>
                        <div class="epg-description">${channel}</div>
                    `;
                    
                    container.appendChild(card);
                });
            });
        }
        
        function playChannel(channel) {
            const video = document.getElementById('videoPlayer');
            const container = document.getElementById('videoContainer');
            const playing = document.getElementById('currentPlaying');
            const playingName = document.getElementById('playingName');
            
            container.classList.remove('hidden');
            playing.classList.remove('hidden');
            playingName.textContent = channel.name;
            
            debugLog(`üé¨ Lecture de: ${channel.name}`, 'info');

            // V√©rifier que l'objet canal est valide
            if (!channel || !channel.url) {
                debugLog('‚ùå Objet canal invalide ou URL manquante', 'error');
                showStatus('‚ùå Impossible de lancer ce contenu (URL manquante)', 'error');
                return;
            }

            let finalStreamUrl = channel.url;
            let needsProxy = false;
            
            // üé¨ Proxifier l'URL de streaming si activ√© (r√©sout CORS/Mixed Content)
            if (PROXY_STREAMS && channel.url.startsWith('http://')) {
                debugLog('üîó URL originale: ' + channel.url.substring(0, 80) + '...', 'info');
                
                // D√©tecter mixed content
                if (window.location && window.location.protocol === 'https:') {
                    debugLog('‚ö†Ô∏è Mixed content d√©tect√© (HTTPS‚ÜíHTTP), activation du proxy de streaming', 'warning');
                    needsProxy = true;
                    
                    // TOUJOURS sauvegarder l'URL originale pour permettre le retry
                    if (!channel._originalUrl) {
                        channel._originalUrl = channel.url;
                        debugLog('üíæ URL originale sauvegard√©e pour retry automatique', 'info');
                    }
                    
                    // S√©lectionner le meilleur proxy disponible
                    const selectedProxy = selectStreamProxy();
                    
                    if (selectedProxy && selectedProxy.url) {
                        finalStreamUrl = selectedProxy.url + encodeURIComponent(channel.url);
                        debugLog(`üîÑ Proxy s√©lectionn√©: ${selectedProxy.name}`, 'success');
                        debugLog('üîÑ URL proxifi√©e: ' + finalStreamUrl.substring(0, 80) + '...', 'info');
                        showStatus(`üîÑ Flux proxifi√© via ${selectedProxy.name}`, 'success');
                        channel._currentProxy = selectedProxy.name;
                    } else {
                        debugLog('‚ö†Ô∏è Aucun proxy disponible, tentative en direct (risque d\'√©chec)', 'warning');
                        showStatus('‚ö†Ô∏è Aucun proxy disponible, tentative directe...', 'warning');
                    }
                }
            } else {
                debugLog(`üîó URL: ${channel.url.substring(0, 80)}...`, 'info');
            }
            
            // D√©tecter un possible blocage "mixed content" (page HTTPS, flux HTTP)
            try {
                if (!PROXY_STREAMS && window.location && window.location.protocol === 'https:' && channel.url.startsWith('http://')) {
                    debugLog('‚ö†Ô∏è Mixed content d√©tect√©: page HTTPS mais flux HTTP', 'warning');
                    showStatus('‚ö†Ô∏è Le flux utilise HTTP alors que la page est charg√©e en HTTPS. Le navigateur peut bloquer la vid√©o. Active PROXY_STREAMS ou utilise HTTPS.', 'warning');
                }
            } catch (e) {
                // Ne jamais casser la lecture √† cause d'un simple check d'environnement
                debugLog(`‚ö†Ô∏è Erreur pendant la d√©tection mixed content: ${e.message}`, 'warning');
            }
            
            // Arr√™ter HLS pr√©c√©dent
            if (hls) {
                debugLog('üõë Arr√™t du stream pr√©c√©dent', 'info');
                hls.destroy();
                hls = null;
            }
            
            // R√©initialiser le player
            video.pause();
            video.removeAttribute('src');
            video.load();
            
            // D√©tecter si c'est HLS (.m3u8)
            if (channel.url.includes('.m3u8')) {
                debugLog('üì° Format d√©tect√©: HLS (M3U8)', 'info');
                
                // V√©rifier support natif HLS (Safari, certains navigateurs Android)
                if (video.canPlayType('application/vnd.apple.mpegurl')) {
                    debugLog('‚úÖ Support HLS natif du navigateur', 'success');
                    video.src = finalStreamUrl;
                    video.play().catch(e => {
                        debugLog(`‚ùå Erreur lecture native: ${e.message}`, 'error');
                        showStatus('‚ùå Impossible de lire ce flux HLS (lecture native). Tentative automatique via HLS.js...', 'error');

                        if (typeof Hls !== 'undefined' && Hls.isSupported()) {
                            debugLog('üîÅ Fallback automatique: tentative de lecture via HLS.js apr√®s √©chec natif', 'warning');

                            if (hls) {
                                try {
                                    hls.destroy();
                                } catch (_) {}
                                hls = null;
                            }

                            const hlsConfig = {
                                enableWorker: true,
                                lowLatencyMode: false,
                                backBufferLength: 90,
                                maxBufferLength: 30,
                                maxMaxBufferLength: 60,
                                maxBufferSize: 60 * 1000 * 1000,
                                maxBufferHole: 0.5,
                                highBufferWatchdogPeriod: 2,
                                nudgeOffset: 0.1,
                                nudgeMaxRetry: 3,
                                maxFragLookUpTolerance: 0.25,
                                liveSyncDurationCount: 3,
                                liveMaxLatencyDurationCount: 10,
                                liveDurationInfinity: false,
                                preferManagedMediaSource: false,
                                abrEwmaDefaultEstimate: 500000
                            };

                            try {
                                hls = new Hls(hlsConfig);

                                hls.on(Hls.Events.MEDIA_ATTACHED, () => {
                                    debugLog('üì∫ HLS (fallback) attach√© au player', 'success');
                                });

                                hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
                                    debugLog(`‚úÖ Manifest (fallback) pars√©: ${data.levels.length} qualit√©s disponibles`, 'success');
                                    video.play().catch(err2 => {
                                        debugLog(`‚ùå Erreur autoplay apr√®s fallback HLS.js: ${err2.message}`, 'error');
                                        showStatus('‚ùå Lecture automatique bloqu√©e apr√®s fallback HLS.js. Essayez d\'appuyer sur ‚ñ∂Ô∏è dans la vid√©o.', 'error');
                                    });
                                });

                                hls.on(Hls.Events.ERROR, (event, data) => {
                                    if (data.fatal) {
                                        debugLog(`‚ùå Erreur HLS (fallback) fatale: ${data.type} - ${data.details}`, 'error');
                                        showStatus('‚ùå Erreur HLS fatale apr√®s fallback: ' + (data.details || data.type), 'error');
                                        
                                        // Si c'est une erreur manifestLoad ou networkError et qu'on utilise un proxy
                                        if ((data.details === 'manifestLoadError' || data.type === Hls.ErrorTypes.NETWORK_ERROR) && channel._originalUrl) {
                                            debugLog('üîÑ Erreur de chargement d√©tect√©e, tentative avec proxy suivant...', 'warning');
                                            hls.destroy();
                                            retryPlayWithNextProxy(channel);
                                            return;
                                        }
                                        
                                        switch (data.type) {
                                            case Hls.ErrorTypes.NETWORK_ERROR:
                                                debugLog('üîÑ Tentative de r√©cup√©ration r√©seau (fallback)...', 'warning');
                                                hls.startLoad();
                                                break;
                                            case Hls.ErrorTypes.MEDIA_ERROR:
                                                debugLog('üîÑ Tentative de r√©cup√©ration m√©dia (fallback)...', 'warning');
                                                hls.recoverMediaError();
                                                break;
                                            default:
                                                debugLog('üíî Impossible de r√©cup√©rer apr√®s fallback, destruction HLS', 'error');
                                                hls.destroy();
                                                break;
                                        }
                                    } else {
                                        debugLog(`‚ö†Ô∏è Erreur HLS (fallback) non-fatale: ${data.details}`, 'warning');
                                    }
                                });

                                hls.loadSource(finalStreamUrl);
                                hls.attachMedia(video);
                            } catch (fallbackError) {
                                debugLog(`‚ùå Fallback HLS.js en √©chec: ${fallbackError.message}`, 'error');
                                showStatus('‚ùå La lecture a √©chou√© en mode natif et via HLS.js. Flux probablement non compatible avec ce navigateur.', 'error');
                            }
                        } else {
                            debugLog('‚ùå Aucun fallback HLS.js disponible sur ce navigateur', 'error');
                        }
                    });
                }
                // Sinon utiliser HLS.js (Chrome, Firefox, etc.)
                else if (typeof Hls !== 'undefined' && Hls.isSupported()) {
                    debugLog('‚úÖ Utilisation de HLS.js', 'success');
                    
                    // Configuration optimis√©e pour Android/XPENG (hardware decode)
                    const hlsConfig = {
                        enableWorker: true,
                        lowLatencyMode: false,
                        backBufferLength: 90,
                        maxBufferLength: 30,
                        maxMaxBufferLength: 60,
                        maxBufferSize: 60 * 1000 * 1000,
                        maxBufferHole: 0.5,
                        highBufferWatchdogPeriod: 2,
                        nudgeOffset: 0.1,
                        nudgeMaxRetry: 3,
                        maxFragLookUpTolerance: 0.25,
                        liveSyncDurationCount: 3,
                        liveMaxLatencyDurationCount: 10,
                        liveDurationInfinity: false,
                        preferManagedMediaSource: false,
                        // Forcer le d√©codage hardware si possible
                        abrEwmaDefaultEstimate: 500000
                    };
                    
                    hls = new Hls(hlsConfig);
                    
                    hls.on(Hls.Events.MEDIA_ATTACHED, () => {
                        debugLog('üì∫ HLS attach√© au player', 'success');
                    });
                    
                    hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
                        debugLog(`‚úÖ Manifest pars√©: ${data.levels.length} qualit√©s disponibles`, 'success');
                        video.play().catch(e => {
                            debugLog(`‚ùå Erreur autoplay: ${e.message}`, 'error');
                            showStatus('‚ùå Lecture automatique bloqu√©e par le navigateur. Essayez d\'appuyer sur ‚ñ∂Ô∏è dans la vid√©o.', 'error');
                        });
                    });
                    
                    hls.on(Hls.Events.ERROR, (event, data) => {
                        if (data.fatal) {
                            debugLog(`‚ùå Erreur HLS fatale: ${data.type} - ${data.details}`, 'error');
                            showStatus('‚ùå Erreur HLS fatale: ' + (data.details || data.type), 'error');
                            
                            // Si c'est une erreur manifestLoad ou networkError et qu'on utilise un proxy
                            if ((data.details === 'manifestLoadError' || data.type === Hls.ErrorTypes.NETWORK_ERROR) && channel._originalUrl) {
                                debugLog('üîÑ Erreur de chargement d√©tect√©e, tentative avec proxy suivant...', 'warning');
                                hls.destroy();
                                retryPlayWithNextProxy(channel);
                                return;
                            }
                            
                            switch (data.type) {
                                case Hls.ErrorTypes.NETWORK_ERROR:
                                    debugLog('üîÑ Tentative de r√©cup√©ration r√©seau...', 'warning');
                                    hls.startLoad();
                                    break;
                                case Hls.ErrorTypes.MEDIA_ERROR:
                                    debugLog('üîÑ Tentative de r√©cup√©ration m√©dia...', 'warning');
                                    hls.recoverMediaError();
                                    break;
                                default:
                                    debugLog('üíî Impossible de r√©cup√©rer, destruction HLS', 'error');
                                    hls.destroy();
                                    break;
                            }
                        } else {
                            debugLog(`‚ö†Ô∏è Erreur HLS non-fatale: ${data.details}`, 'warning');
                        }
                    });
                    
                    hls.loadSource(finalStreamUrl);
                    hls.attachMedia(video);
                } else {
                    debugLog('‚ùå HLS non support√© ou Hls.js non charg√© dans ce navigateur', 'error');
                    showStatus('‚ùå HLS non support√© ou Hls.js non charg√© sur ce navigateur', 'error');
                }
            } 
            // Formats directs (MP4, WebM, etc.)
            else {
                debugLog('üìπ Format d√©tect√©: Vid√©o directe (MP4/WebM)', 'info');
                video.src = finalStreamUrl;
                video.play().catch(e => {
                    debugLog(`‚ùå Erreur lecture: ${e.message}`, 'error');
                    showStatus('‚ùå Impossible de lire cette vid√©o', 'error');
                });
            }
            
            // √âv√©nements vid√©o
            video.addEventListener('loadstart', () => debugLog('‚è≥ Chargement...', 'info'), { once: true });
            video.addEventListener('canplay', () => debugLog('‚úÖ Vid√©o pr√™te', 'success'), { once: true });
            video.addEventListener('playing', () => debugLog('‚ñ∂Ô∏è Lecture en cours', 'success'), { once: true });
            video.addEventListener('waiting', () => debugLog('‚è∏Ô∏è Buffering...', 'warning'), { once: true });
            video.addEventListener('error', (e) => {
                const mediaError = e.target && e.target.error ? e.target.error : null;
                const code = mediaError && typeof mediaError.code === 'number' ? mediaError.code : null;
                const message = mediaError && mediaError.message ? mediaError.message : 'Unknown';

                debugLog(`‚ùå Erreur vid√©o: code=${code !== null ? code : 'N/A'}, message="${message}"`, 'error');

                if (code === 4) { // MEDIA_ERR_SRC_NOT_SUPPORTED
                    debugLog('‚ùå Flux non compatible: format ou codec non support√© par le navigateur', 'error');
                    showStatus('‚ùå Le flux vid√©o n\'est pas compatible avec ce navigateur (format ou codec non support√©). Essayez un autre flux ou contactez votre fournisseur IPTV.', 'error');
                } else if (code === 3) { // MEDIA_ERR_DECODE
                    debugLog('‚ö†Ô∏è Erreur de d√©codage m√©dia (MEDIA_ERR_DECODE)', 'warning');
                    showStatus('‚ö†Ô∏è Le flux a rencontr√© une erreur de d√©codage. Essayez de relancer la cha√Æne ou une autre cha√Æne.', 'warning');
                } else if (code === 2) { // MEDIA_ERR_NETWORK
                    debugLog('‚ö†Ô∏è Erreur r√©seau pendant la lecture (MEDIA_ERR_NETWORK)', 'warning');
                    showStatus('‚ö†Ô∏è Erreur r√©seau pendant la lecture du flux. V√©rifiez votre connexion Internet ou celle du serveur IPTV.', 'warning');
                } else if (code === 1) { // MEDIA_ERR_ABORTED
                    debugLog('‚ö†Ô∏è Lecture interrompue par le syst√®me ou l\'utilisateur (MEDIA_ERR_ABORTED)', 'warning');
                    showStatus('‚ö†Ô∏è La lecture du flux a √©t√© interrompue. Relancez la cha√Æne si besoin.', 'warning');
                }
            }, { once: true });
            
            // Scroll vers le player
            setTimeout(() => {
                container.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 300);
        }
        
        function showPlayer() {
            document.getElementById('setupSection').classList.add('hidden');
            document.getElementById('playerSection').classList.remove('hidden');
        }
        
        function showSetup() {
            document.getElementById('setupSection').classList.remove('hidden');
            document.getElementById('playerSection').classList.add('hidden');
        }
        
        function showStatus(message, type) {
            // Statut dans la section player
            const status = document.getElementById('statusMessage');
            if (status) {
                status.style.display = 'block';
                status.textContent = message;
                status.className = 'status-message status-' + type;

                setTimeout(() => {
                    status.style.display = 'none';
                }, 5000);
            }

            // Statut directement sous le formulaire de configuration (pendant le setup)
            const setupStatus = document.getElementById('setupStatus');
            const setupSection = document.getElementById('setupSection');
            if (setupStatus && setupSection && !setupSection.classList.contains('hidden')) {
                setupStatus.style.display = 'block';
                setupStatus.textContent = message;
                setupStatus.className = 'status-message status-' + type;
            }
        }
        
        function clearStorage() {
            if (confirm('Voulez-vous vraiment effacer toutes les donn√©es sauvegard√©es ?')) {
                localStorage.removeItem('iptvConfig');
                location.reload();
            }
        }
    </script>
</body>
</html>
